#시작, 종료 위치를 알면 그것만 가져올 수 있음
read_fwf(file = "product_fix.txt",
col_positions = fwf_cols(name=c(6,15),price=c(16,23)))
#필드가 공백으로 구분된 경우 편히 가져올 수 있음
read_table(file = "product_fix.txt",
col_names = c('id','name','price'))
openFileInOS("product.csv")
openFileInOS("product.txt")
read_table(file = "product.csv",
col_names = c('id','name','price'))
read_table(file = "product.txt",
col_names = c('id','name','price'))
openFileInOS("word.txt")
read_lines(file="word.txt")
#원하는 라인만 읽음
read_lines(file="word.txt", skip=1, nmax=3)
#원하는 라인만 읽음
read_lines(file="word.txt", skip=1, n_max=3)
#라인단위로 읽어올 수 있음
openFileInOS("word.txt")
read_file(file = "word.txt")
Orange
write_csv(x=Orange, file = "orange.csv")
read_csv(file="orange.csv")
write_delim(x=Orange, file = "orange2.txt", delim=";")
read_delim(file='orange2.txt', delim = ";")
#저장하기
write_lines(x=Orange$circumference, file = 'c.txt')
read_lines("c.txt")
#숫자의 앞이나 뒤에 있는 문자를 제거하고 숫자로 반환
parse_number("$100")
class(parse_number("$100"))
parse_number("30%")
parse_number("60.5Kg")
parse_number("Salary per year : $200,000")
parse_number("Salary per year : $20,000")
parse_number("Salary per year : $25,000")
parse_number("Salary per year : $25000")
parse_number("Salary per year : $2500,000")
parse_number("Salary per year : $250,000")
return(result)
#함수
transLength <- function(x){
tlength <- round(x*0.9144, digits = 1)
result <- paste(tlength, "m", sep="")
return(result)
}
ls()
y <- c(100,150,200)
transLength(y)
#R에서는 함수역시 객체이다 다른 객체에 할당함으로 복사 가능
trans2 <- transLength
trans2
trans2(y)
#return 없애고 적재하면 리턴 값 없음
transLength <- function(x){
tlength <- round(x*0.9144, digits = 1)
result <- paste(tlength, "m", sep="")
}
transLength(y)
print(transLength(y))
#숫자가 아닌경우 종료하기 추가
transLength <- function(x){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*0.9144, digits = 1)
paste(tlength, "m", sep="")
}
transLength("ABC")
#함수 만들어 보기
f1 <- function(x,y) {x+y}
f2 <- function(x,y) x+y
f1(1,3)
f2(1,3)
transLength <- function(x) paste(round(x*0.9144, digits = 1),"m", sep="")
transLength(y)
#길이변환 함수 만들기
transLength <- function(x, multi, unit){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, digits = 1)
paste(tlength, unit, sep="")
}
transLength(y, multi=3, unit="ft")
transLength(y, multi=36, unit="inch")
transLength(y)
tlength <- round(x*multi, digits = 1)
#초기값 설정
transLength <- function(x, multi=0.9144, unit="m"){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, digits = 1)
paste(tlength, unit, sep="")
}
transLength(y)
transLength(y, multi=3, unit="ft")
#내부함수 사용하는 인수들 정할 수 있다
transLength <- function(x, multi=0.9144, unit="m", ...){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, ...)
paste(tlength, unit, sep="")
}
transLength(y, digits=2)
transLength(y)
tlength <- round(x*multi, digits = digits)
#내부함수 인수 초기화
transLength <- function(x, multi=0.9144, unit="m", digits=1){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, digits = digits)
paste(tlength, unit, sep="")
}
transLength(y)
#내부함수에 초기 함수를 설정할 수 있음
transLength <- function(x, multi=0.9144, unit="m", FUN=round, ...){
tlength <- FUN(x*multi, ...)
paste(tlength, unit, sep="")
}
transLength(y)
transLength(y, FUN=signif, digits = 3)
transLength(y, FUN=floor)
ls()
x <- 11:15
scopetest <- function(x){
cat("This is x :", x, "\n")
rm(x)
cat("This is after removing x", x, "\n")
}
scopetest(x=15:11)
#논리흐름 제어
x <- pi
y <- 3
if(x>y) x
if(x<y) x
if(x<y) x else y
if(x>y) x else y
#벡터는 조건문에 들어갈 수 없고, 들어가더라도 처음 인자만 조건에 들어감
x <- pi
y <- 1:5
if(x<y) x else y
if(x>y) x else y
#벡터 연산을 통해서
test <- c(TRUE, FALSE, TRUE, TRUE, FALSE )
yes <- 1:5
no <- 0
ifelse(test, yes, no)
x>y
ifelse(x>y, x , y)
#첫번째 조건에 따라 2번째 이후 수행
center <- function(x, type){
swtich(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1)
)
}
x <- c(2,3,5,7,11,13,17,19,23,29)
center(x, "mean")
switch(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1)#절삭평균
)
#첫번째 조건에 따라 2번째 이후 수행
center <- function(x, type){
switch(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1)#절삭평균
)
}
center(x, "mean")
center(x, "median")
center(x, "trimmed")
center <- function(x, type){
switch(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1),#절삭평균
"Choose one of mean, median, trimmed."
)
}
center(x, "other")
repeat print("hello")
i <- 5
repeat {if(i>25) break
else {print(i)
i <- i+5}
}
i <- 5
while(i<=25){
print(i)
i <- i + 5
}
#for (var in list) statement
for (i in seq(from=5, to=25, by=5)) print(i)
for  (i in seq(from=5, to=25, by=5)) i
i <- 1
for  (i in seq(from=5, to=25, by=5)) i
i
mode(1.414)
mode(c(1:3))
mode("Batman")
mode(c("Batman", "Superman","Spiderman"))
mode(factor("High","Medium","Low"))
mode(as.Date("2030-12-31"))
mode(5>2)
mode(list(1.23, "Apple",c(2,3,4,5)))
mode(data.frame(x=1:3, y=c("H","M","L")))
mode(mean)
#class 숫자로는 물리적으로 하나의 형태로 저장되더라도 동시에 여러개로 나타날 수 있다
d <- as.Date("2030-12-31")
mode(d)
length(d)
class(d)
#class가 date 이기 때문에 일반 숫자가 아니라 날짜로 인지한다
as.integer(d)
d+1
methods(print)
#변환이 불가하면 NA 출력
as.numeric(1.414)
as.integer(1.414)
as.character(1.414)
as.numeric("gold")
as.numeric(c("-1","1.414", "3.14"))
as.numeric(c("-1","1.414", "3.14", "and"))
as.character(11:15)
as.numeric(TRUE)
as.numeric(FALSE)
#vector
vec <- 1:6
vec
as.list(vec)
list(vec)
#하나의 열을 가진 행렬 만들기
cbind(vec)
as.matrix(vec)
rbind(vec)
matrix(vec, 2,3)
as.data.frame(vec)
as.data.frame(rbind(vec))
#matrix
mat <- matrix(1:6, 2,3)
mat
as.vector(mat)
as.list(mat)
list(mat)
as.data.frame(mat)
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
lst
unlist(lst)
as.vector(lst)
as.vector(unlist(lst))
lst <- list(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
lst
unlist(lst)
lst2 <- list(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
lst2
#문자가 있으면 전체가 다 문자로 바뀜
unlist(lst2)
matrix(lst2)
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst))
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
unlist(lst)
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
matrix(lst)
as.matrix(lst)
as.data.frame(lst)
as.data.frame(lst2)
str(as.data.frame(lst2))
#data frame
dfm <- data.frame(odd=c(1,3,5), even=c(2,4,6))
dfm
dfm[,1]
dfm[[1]]
str(dfm[,1])
str(dfm[[1]])
dfm[1,]
str(dfm[1,])
as.matrix(dfm)
as.vector(as.matrix(dfm))
dfm2 <- data.frame(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
dfm2
as.vector(as.matrix(dfm2))
#dataframe->list
as.list(dfm2)
as.matrix(dfm2)
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
install.packages(quantmod)
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
install.packages("quantmod")
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
#install.packages("quantmod")
library(quantmod)
sec <- getSymbols(Symbols = "005930.ks",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
sec <- as.data.frame(sec)
str(sec)
head(sec)
head(sec[c("005930.KS.Close", "005930.KS.Volume")])
sec <- cbind(date=rownames(sec),
symbol="005930.KS",
sec[c("005930.KS.Close", "005930.KS.Volume")])
rownames(sec) <- NULL #행이름 지지우기
colnames(sec)[c(3,4)] <- c("close", "volume")
head(sec)
#현대자동차 주가정보 다운로드
hmc <- getSymbols(Symbols = "005387.ks",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
hmc <- as.data.frame(hmc)
head(hmc)
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
sec[c("005387.KS.Close", "005930.KS.Volume")])
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
sec[c("005387.KS.Close", "005387.KS.Volume")])
#현대자동차 주가정보 다운로드
hmc <- getSymbols(Symbols = "005387.KS",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
hmc <- as.data.frame(hmc)
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
hmc[c("005387.KS.Close", "005387.KS.Volume")])
head(hmc)
rownames(hmc) <- NULL
head(hmc)
colnames(hmc)[c(3,4)] <- c("close", "volume")
head(hmc)
#행의 방향으로 결함
stock <- rbind(sec, hmc)
head(stock)
stock
#merge로 환율 데이터 옆에 붙이기
#finance.yahoo.com
fx <- getSymbols(Symbols = "KRW=X",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
fx
#데이터프레임 형태로 변환
fx <- as.data.frame(fx)
str(fx)
head(fx["KRW=X.Close"])
fx <- cbind(date=rownames(fx),
fx[c("KRW=X.Close")])
head(fx)
rownames(fx) <- NULL
head(fx)
colnames(fx) <- "close"
head(fx)
#merge로 환율 데이터 옆에 붙이기
#finance.yahoo.com
fx <- getSymbols(Symbols = "KRW=X",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
#데이터프레임 형태로 변환
fx <- as.data.frame(fx)
str(fx)
head(fx["KRW=X.Close"])
fx <- cbind(date=rownames(fx),
fx[c("KRW=X.Close")])
head(fx)
rownames(fx) <- NULL
colnames(fx)[c(2)] <- "close"
head(fx)
#공통된 날짜 기준으로 merge
instersect(names(sec), names(fx))
#공통된 날짜 기준으로 merge
intersect(names(sec), names(fx))
report <- merge(sec, fx, by="date")
report
v <- c(10,9,8,7,5,4,3,2,1)
match(7,v)
match(c(11,5,3,1,0), v)
v <- c(10,9,8,7,6,5,4,3,2,1)
match(7,v)
match(c(11,5,3,1,0), v)
head(mtcars)
car <- mtcars
car["name"] <- rownames(car)
rownames(car) <- NULL
head(car)
highhp.car <- car[car$hp>145,]
highhp.car
lightwt.car <- car[car$wt>3.2,]
lightwt.car
lightwt.car <- car[car$wt<3.2,]
lightwt.car
#힘이 좋으면서 가벼운 차 위의 2dataframe 합치기
index <- match(highhp.car$name, lightwt.car$name)
index
lightwt.car[na.omit(index),]
v <- c(10,9,8,7,6,5,4,3,2,1)
7 %in% v
c(1,2,3) %in% v
c(11,5,0) %in% v
index2 <- highhp.car$name %in% lightwt.car$name
index2
highhp.car[index2,]
#subset | 인덱싱 | $ [[ ]] [ ] | 무작위 표본(random sample) 추출 | 결측값 | 구간별 범주화
str(mtcars)
mtcars$mpg
mtcars[[mpg]]
mtcars[["mpg"]]
mtcars[[1]]
mtcars["mpg"]
mtcars[c(1,4)]
mtcars[c("mpg","hp")]
mtcars[-c(2,3,4)]
mtcars[-1]
mtcars[1] <- NULL
mtcars
mtcars[c(-1, 2)]
str(iris)
iris[1:5]
iris[1:5,]
iris[1:5]
iris[1:2]
iris[,c(1,4)]
iris[,1]
iris[,1, drop=FALSE]
#원래 형태로 하고 싶으면 행렬인덱싱보다 리스트 인덱싱을 쓰는 것이 안전하다
iris[1]
iris[1:5,c(1,4)]
#조건에 따라서 만드는 경우
iris[iris$Sepal.Length>7,]
iris[iris$Sepal.Length>7,c(1,2)]
iris[iris$Sepal.Length>7,c(1,2,5)]
subset(iris, subset=(Sepal.Length>7),
select =c(1,2,5))
#랜덤 샘플링 할 때
sample(x1:10, size=5)
#랜덤 샘플링 할 때
sample(x=1:10, size=5)
sample(x=10, size=5)
#복원추출
sample(x=10, size = 5, replace = TRUE)
sample(10)
#sample이 일정하게 나오면 좋겠다. seed 지정
set.seed(1)
sample(x=10, size = 5, replace=TRUE)
sample(x=10, size = 5, replace=TRUE)
set.seed(1)
sample(x=10, size = 5, replace=TRUE)
sample(iris,3)
set.seed(1)
index <- sample(nrow(iris),3)
index
iris[index]
iris[index,]
#데이터셋에 중복된 값 제거하고 subset 생성하기
duplicated(c(1,2,3,1,1,3,4))
#결측값이 있는 경우 결측값이 뭔지 지정해줘야 함
openFileInOS("product_missing.csv")
#install.packages("tidyverse")
library(readr)
read_csv(file = "product.csv") #첫 행에 열이름이 있는 경우
id <- c("A001","A002","A003")
name <- c("Mouse","Keyboard","USB")
price <- c(30000,90000,50000)
product <- data.frame(id=id, name=name, price=price)
product
product <- rbind(product, c("A001","Mouse",30000))
product
duplicated(product)
product[duplicated(product), ]
product[-duplicated(product), ]
product[!duplicated(product), ]
which(duplicated(product))
product[-index,]
index <- which(duplicated(product))
product[-index,]
#방법4
unique(product)
#방법5
str(airquality)
complete.cases(airquality)
airquality.nona <- airquality[complete.cases(airquality),]
str(airquality)
str(airquality.nona)
#방법6
airquality.nona2 <- na.omit(airquality)
str(airquality.nona2)
#범주화 하기
cut(x=iris$Sepal.Width, breaks=c(0,1,2,3,4,5))
cut(x=iris$Sepal.Width, breaks=5)#임의로 5개의 구간을 나눔눔
#빈도 계산을 위해서는 table 사용
iris.cut <- cut(x=iris$Sepal.Width, breaks=c(0,1,2,3,4,5))
table(iris.cut)
summary(iris.cut)
iris.cut <- cut(x=iris$Sepal.Width,
breaks = c(0,1,2,3,4,5),
labels = c("smaller","small","medium","big","biger"))
table(iris.cut)
