arrange(df, desc(w), y)
head(mtcars)
#am 변수를 가지고 집단으로 만들어봄
mtcars <- within(mtcars,
am <- factor(am,
levels = c(0,1),
labels = c("Automatic","Manual")))
head(mtcars)
g <- split(mtcars$mpg, f=mtcars$am)
g
g[[1]]
mean(g[[1]])
mean(g[["Manual"]])
sapply(g,mean)
unstack(data.frame(mtcars$mpg, mtcars$am))
head(iris)
unstack(data.frame(iris$Sepal.Length, iris$Species))
gg<- unstack(data.frame(iris$Sepal.Length, iris$Species))
head(gg)
str(gg)
summary(gg)
tapply(X=iris$Sepal.Length, INDEX = iris$Species, FUN=mean)
tapply(X=iris$Sepal.Length, INDEX = iris$Species, FUN=length)
with(tapply(mtcars$mpg, list(cyl,am), mean))
str(mtcars)
with(tapply(mtcars$mpg, list(cyl ,am), mean))
with(tapply(mpg, list(cyl ,am), mean))
with(mtcars,tapply(mpg, list(cyl ,am), mean))
with(mtcars,tapply(mpg, list(Cylincer=cyl ,Transmission=am), mean))
FUN=mean)
with(mtcars,
aggregate(x=mpg, by=list(Cylincer=cyl ,Transmission=am),
FUN=mean))
aggregate(mtcars[1:6], list(Group.cyl=cyl ,Group.am=am),
FUN=mean))
aggregate(mtcars[1:6], list(Group.cyl=cyl ,Group.am=am),
FUN=mean)
aggregate(mtcars[1:6], list(Group.cyl=mtcars$cyl ,Group.am=mtcars$am),
FUN=mean)
aggregate(iris[1:4], list(Species=iris$Species), mean)
by(data=iris, INDICES = iris$Species, FUN=summary)
by(data=iris, INDICES = iris$Species, FUN=summary)
by(iris, iris$Species, function(x) mean(x$Sepal.Length))
#범주형 변수가 주어지면 변수가 몇개인가 알려줌
table(mtcars$gear)
table(mtcars$am)
table(mtcars$am, mtcars$gear)
table(mtcars$am, mtcars$gear)
cut(mtcars$mpg, breaks = 5)
#균일한 구간으로 나눔
mpg.cut <- cut(mtcars$mpg, breaks = 5)
table(mpg.cut)
head(airquality)
install.packages("dplyr")
#install.packages("dplyr")
library(dplyr)
filter(airquality, Month==6)
air <- filter(airquality, Month==6)
head(air)
airquality[airquality$Month==6,]
subset(airquality, subset = (Month==6))
air <- filter(airquality, Month==6, Temp>90)
head(air)
air <- filter(airquality, Month==6 & Temp>90)
head(air)
air <- filter(airquality, Ozone>80 | Temp>90)
head(air)
#원하는 행 추출
slice(airquality, 6:10)
#n():dataframe의 행번호
slice(airquality, (n()-4):n())
#여러 열을 지정가능 순서대로 arrange됨
arrange(airquality, Temp, Month, Day)
arrange(airquality, desc(Temp), Month, Day)
#원하는 열을 선택
air <- select(airquality, Month, Day, Temp)
head(air)
air <- select(airquality, Temp:Day)
head(air)
#원하지 않는 열 빼기
air <- select(airquality, -(Temp:Day))
head(air)
#선택하면서 열이름 바꿀수도 있음
air <- select(airquality, Solar=Solar.R)
head(air)
#이름만 변경하려면 rename()을 써서 특정 열의 이름 변경
air <- rename(airquality, Solar=Solar.R)
head(air)
#중복되지 않는 값 출력
distinct(select(airquality, Month))
#새로운 열을 추가할 때 사용
air <- mutate(airquality,
Temp.c=(Temp-32)/1.8,
Diff=Temp.c-mean(Temp.c))
head(air)
#base package 포함된 transform()
transform(airquality,
Temp.c=(Temp-32)/1.8,
Diff=Temp.c-mean(Temp.c))
transform(airquality,
Temp.c=(Temp-32)/1.8)
head(air)
#요약통계
summarise(airquality,
mean(Temp))
#요약통계
summarise(airquality,
mean(Temp, na.rm = TRUE),
median(Temp, na.rm = TRUE),
sd(Temp, na.rm = TRUE),#표준편차
max(Temp, na.rm = TRUE),
min(Temp, na.rm = TRUE))
#요약통계
summarise(airquality,
Mean=mean(Temp, na.rm = TRUE),
Median=median(Temp, na.rm = TRUE),
SD=sd(Temp, na.rm = TRUE),#표준편차
Max=max(Temp, na.rm = TRUE),
Min=min(Temp, na.rm = TRUE))
#요약통계
summarise(airquality,
Mean=mean(Temp, na.rm = TRUE),
Median=median(Temp, na.rm = TRUE),
SD=sd(Temp, na.rm = TRUE),#표준편차
Max=max(Temp, na.rm = TRUE),
Min=min(Temp, na.rm = TRUE),
N=n(),#열의 개수
Distinct.Month=n_distinct(Month)#고유한 값의 개수
Distinct.First=first(Month)#첫번째 값
Distinct.Last=last(Month)
)
#요약통계
summarise(airquality,
Mean=mean(Temp, na.rm = TRUE),
Median=median(Temp, na.rm = TRUE),
SD=sd(Temp, na.rm = TRUE),#표준편차
Max=max(Temp, na.rm = TRUE),
Min=min(Temp, na.rm = TRUE),
N=n(),#열의 개수
Distinct.Month=n_distinct(Month),#고유한 값의 개수
Distinct.First=first(Month),#첫번째 값
Distinct.Last=last(Month)
)
#무작위 추출, 지정된 개수, 지정된 비율로
sample_n(airquality, 5)
#무작위 추출, 지정된 개수, 지정된 비율로
sample_n(airquality, 5, seed=1)
#무작위 추출, 지정된 개수, 지정된 비율로
sample_n(airquality, 5, seed=1)
#
air.group <- group_by(airquality, Month)
class(air.group)
air.group
summarise(air.group,
Mean.Temp=mean(Temp, na.rm=TRUE))
summarise(air.group,
Mean.Temp=mean(Temp, na.rm=TRUE),
sd.Temp=sd(Temp, na.rm = TRUE),
Days=n())
#pipe operator %>%
#결과를 다음에 첫 인자로 전달 가능
iris %>% head
head(iris)
1:10 %>% mean
mean(1:10)
a1 <- select(airquality, Ozon, Temp, Month)
head(a1)
a1 <- select(airquality, Ozon, Temp, Month)
a1 <- select(airquality, Ozone, Temp, Month)
head(a1)
a2 <- group_by(a1, Month)
head(a2)
a2
a3 <- summarise(a2,
Mean.ozone=mean(Ozone,na.rm=TRUE),
Mean.Temp=mean(Temp, na.rm=TRUE))
a3
a4 <- filter(a3, Mean.ozone>40 | Mean.Temp>80)
a4
#pipe operator 사용해서 똑같이 해보기
air <- airquality %>%
select( Ozone, Temp, Month) %>%
group_by(Month) %>%
summarise(Mean.ozone=mean(Ozone,na.rm=TRUE),
Mean.Temp=mean(Temp, na.rm=TRUE)) %>%
filter(Mean.ozone>40 | Mean.Temp>80)
air
#조인
df1 <- data.frame(x=1:6, y=month.name[1:6])
df2 <- data.frame(x=7:12, y=month.name[7:12])
df1
df2
df3 <- bind_rows(df1, df2)
df3
df4 <- data.frame(z=month.abb)
df4
#열의 방향으로 결합
bind_cols(df3, df4)
#열의 방향으로 결합
df5 <- bind_cols(df3, df4)
df5
cbind(df3,df4)
band_members
band_instruments
inner_join(band_members, band_instruments)
#by 인수를 지정
inner_join(band_members, band_instruments, by="name")
#outer join 한쪽 데이터셋에만 있어도 포함 합집합
left_join(band_members, band_instruments, by="name")#왼쪽 데이터셋 기준
right_join(band_members, band_instruments, by="name")#오른쪽 데이터셋 기준
full_join(band_members, band_instruments, by="name")#왼쪽,오른쪽 둘 모두 데이터셋 기준
band_instruments2
#행이름 다른경우 지정
full_join(band_members, band_instruments2, by=c("name"="airtist"))
#행이름 다른경우 지정
full_join(band_members, band_instruments2, by=c("name"="artist "))
#행이름 다른경우 지정
full_join(band_members, band_instruments2, by=c("name"="artist"))
#행이름 유지하려면
full_join(band_members, band_instruments2, by=c("name"="artist"),keep=TRUE)
#공통열이 일치하는 경우 추출
semi_join(band_members, band_instruments, by="name")
#공통열이 일치하지 않는 경우 추출
anti_join(band_members, band_instruments, by="name")
?apply
x <- matrix(1:20, 4,5)
x
pmax(x)
apply(x, margin=1, max) #margin1:행, 2:열
apply(x, margin=1, FUN=max) #margin1:행, 2:열
apply(x, MARGIN = =1, FUN=max) #margin1:행, 2:열
apply(x, MARGIN = 1, FUN=max) #margin1:행, 2:열
apply(x, MARGIN = 2, FUN=min) #margin1:행, 2:열
y <- array(1:24, c(4,3,2))
y
apply(y, 1, paste, collapse=",")
apply(y, 2, paste, collapse=",")
apply(y, 3, paste, collapse=",")
#margin에 2개 이상의 벡터 넣을 수 있음
apply(y, c(1,2), paste, collapse=",")
apply(y, c(1,2,3), paste, collapse=",")
Titanic
str(Titanic)
apply(Titanic, 1, sum)
apply(Titanic, 4, sum)
apply(Titanic, 1, sum)#Class
apply(Titanic, 2, sum)#Sex
apply(Titanic, 3, sum)#Age
apply(Titanic, 4, sum)
apply(Titanic, "Survived", sum)
apply(Titanic, c("Class", "Survived"), sum)
apply(Titanic, c(1,4), sum)
exams <- list(s20=c(78,89,91,85,95,98),
s21=c(85,86,97,99,90),
s22=c(98,96,78,90,93,85,92),
s23=c(98,96,91,88,93,99))
exams
lapply(exams, 1, length)
lapply(exams, length)
sapply(exams, length) #학기별 학생수
sapply(exams, mean) #학기별 평균
sapply(exams, sd) #학기별 표준편차
sapply(exams, range) #학기별 최소,최대값
sapply(exams, range) #학기별 최소,최대값 출력이 2개면 행렬로 만들어줌
head(iris)
lapply(iris, class)
sapply(iris, class)
sapply(iris, mean)
sapply(iris, function(x) ifelse(is.numeric(x),mean(x),NA))
#using many dataset
mapply(rep, 1:4, 4:1)
rep(1,4)
rep(2,3)
rep(3,2)
rep(4,1)
#purr map()
install.packages("purrr")
#purr map()
#install.packages("purrr")
library(purrr)
exams <- list(s20=c(78,89,91,85,95,98),
s21=c(85,86,97,99,90),
s22=c(98,96,78,90,93,85,92),
s23=c(98,96,91,88,93,99))
exams
map(.x=exams, .f=mean)
map_dbl(exams, mean)
#절삭평균
map_dbl(exams, mean, trim=0.3)
# %>%와 함께 사용하면
exams %>%
map_dbl(mean, trim=0.3)
exams %>%
map(range)
exams %>%
map(range) %>%
map_dbl(diff)
#가산점 주기
exams %>%
map(function(x) x*1.1)
#포뮬러 형식으로 선언하기
exams %>%
map(~.x*1.1)
exams %>%
map(~.*1.1)
fruits <- c("Apple","Banana","Strawberry")
fruits %>%
map_chr(paste,"Juice",sep="-")
fruits %>%
map_chr(~paste(.x,"Juice",sep="-"))
lst <- list(list(num=1:3, letters[1:3]),
list(num=101:103, chr=letters[4:6]),
list(),
list(num=c(9,99), chr=letters[7:9]))
lst
#이름으로 데이터 가져오기
lst %>%
map("num")
lst %>%
map("num", default="???") #null 대신 출력 값 지정
lst %>%
map("num", .default="???") #null 대신 출력 값 지정
lst %>%
map("num", .default=???) #null 대신 출력 값 지정
lst %>%
map("chr", .default="???") #null 대신 출력 값 지정
lst %>%
map("chr", .default=NA)
lst %>%
map(2, .default=NA)
lst %>%
map(c(2,2), .default=NA) @2번째, 2번째 값을 추출출
lst %>%
map(c(2,2), .default=NA) #2번째, 2번째 값을 추출출
lst %>%
map(c(2,2)) #2번째, 2번째 값을 추출출
lst %>%
map_chr(c(2,2)) #2번째, 2번째 값을 추출, chr 아닌 값 있으면 에러
lst %>%
map_chr(c(2,2),.default=NA) #2번째, 2번째 값을 추출, chr 아닌 값 있으면 에러
#문자과 숫자가 섞여 나오면
lst %>%
map(list(num,3))
#문자과 숫자가 섞여 나오면
lst %>%
map(list(num,3))
#문자과 숫자가 섞여 나오면
lst %>%
map(list("num",3))
lst %>%
map(list("num"))
lst %>%
map(list("num",3))
lst %>%
map_int(list("num"), .default=NA)
lst %>%
map_int(list("num",3), .default=NA)
str(USArrests)
#평균값
USArrests %>%
map_dbl(mean)
#최대 최소
USArrests %>%
map_dbl(range)
USArrests %>%
map(range)
USArrests %>%
map_dfr(range)
str(mtcars)
mtcars %>%
split(.$am)
models <- mtcars %>%
split(.$am) %>% #변속이 유형에 따라 2개의 subset 만듬
map(~lm(mpg~wt, data=.))
models
#auto am
model0 <- summary(models$`0`)
str(model0)
names(model0)
model0$r.squared
#자동변속기 유형별 rsquared
models %>%
map(summary) %>%
map_dbl(function(x) x$r.squared)
models %>%
map(summary) %>%
map_dbl(~.$r.squared)
models %>%
map(summary) %>%
map_dbl("r.squared")
mtcars %>%
split(.$am) %>%
map(~lm(mpg~wt, data=.)) %>%
map(summary) %>%
map_dbl("r.squared")
#purr map2()
#여러인수를 가지고 있는 함수를 반복적용 해준다
a <- list(1,2,3)
map(.x=a, function(x) x*1.1)
map_int(.x=a, function(x) x*1.1)
map_dbl(.x=a, function(x) x*1.1)
b <- list(10,20,30)
map2(.x=a, .y=b, .f=function(x,y) y-x)
#fomular 형식
map2(.x=a, .y=b, .f=~.y-.x)
map2_dbl(.x=a, .y=b, .f=~.y-.x)
map2_int(.x=a, .y=b, .f=~.y-.x)
?rnorm
map2(b,a,rnorm, n=5)
set.seed(123)
list(rnorm(mean=10, sd=1, n=5),
rnorm(mean=20, sd=2, n=5),
rnorm(mean=30, sd=3, n=5),
)
list(rnorm(mean=10, sd=1, n=5),
rnorm(mean=20, sd=2, n=5),
rnorm(mean=30, sd=3, n=5)
)
set.seed(123)
map2(b,a,rnorm, n=5) #b:평균, a:표준편차, 추출할 표본개수:5개
set.seed(123)
map2(b,a,rnorm, n=5) #b:평균, a:표준편차, 추출할 표본개수:5개
str(mtcars)
by.am <- mtcars %>%
split(.$am)
by.am
models <- by.am %>%
map(~lm(mpg~wt, data=.))
models
#예측값 구하기
map2(models, by.am, predict)
list(predict(models$`0`, by.am$`0`))
list(predict(models$`1`, by.am$`1`))
#3개의 데이터셋을 활용
a <- list(1,2,3)
b <- list(10,20,30)
c <- list(100,200,300)
pmap(.l-list(a,b,c),.f=sum)
pmap(.l=list(a,b,c),.f=sum)
pmap(list(a,b,c),sum)
pmap_dbl(list(a,b,c),
function(x,y,z) y-x+z)
pmap(list(a,b,c), ~..2-..1+..3)
pmap(list(a,b,c), ~..b-..a+..c)
pmap(list(a,b,c), ~.b-.a+.c)
pmap_dbl(list(alpha=a, beta=b, gamma=c),
function(gamma, beta, alpha) beta-alpha+gamma)
pmap(list(a,b,c), ~..2-..1+..3)
plus <- function(x,y) x+y
pmap_dbl(list(a,b,c), plus)
plus2 <- function(x,y,...) x+y
pmap_dbl(list(a,b,c), plus2)
#무작위 표본 추출하기
args <- list(mean=c(0,5,10),
sd=c(1,2,3),
n=c(1,3,5))
set.seed(123)
args %>%
pmap(rnorm)
set.seed(123)
list(rnorm(mean=0, sd=1, n=1),
rnorm(mean=5, sd=2, n=3),
rnorm(mean=10, sd=3, n=5))
args.df <- data.frame(mean=c(0,5,10),
sd=c(1,2,3),
n=c(1,3,5))
args.df %>%
pmap(rnorm)
args.df
args.df %>%
pmap(rnorm)
#list 이름 없이
args2 <- list(c(0,5,10),
c(1,2,3),
c(1,3,5))
set.seed(123)
args2 %>%
pmap(rnorm)
?rnorm
read.csv(file = "C:/ymyang/word.txt")
read.csv(file = "C:/word.txt", header = FALSE)
read.csv(file = "C:/word.txt", header = FALSE)
read.csv(file = "C:/word.txt")
#reduce
library(purrr)
reduce(.x=c(1,3,5,7), .f=`*`) #연산자는 백틱? esc 아래키로 감싸서 사용
paste2 <- function(u,v,sep=".") paste(u, v, sep=sep)
letters[1:4] %>%
reduce(paste2)
data.frame(name="Batman", grade="A"))
dfs <- list(data.frame(name="Superman", age=30),
data.frame(name=c("Spiderman","Wonderwoman"), sex=c("M","F")),
data.frame(name="Batman", grade="A"))
dfs
library(dplyr)
dfs %>%
reduce(.f=bind_rows)
vs <- list(c(1,3,5,6,7,8,10),
c(2,3,7,8,10),
c(1,2,3,5,7,9,10))
vs
vs %>%
reduce(intersect)
set.seed(123)
x <- sample(10)
x
x %>%
reduce(`+`)
x %>%
accumulate(`+`)
reduce2(.x=letters[1:4],.y=c("-",".","-"),.f=paste2)
accumulate2(.x=letters[1:4],.y=c("-",".","-"),.f=paste2)
