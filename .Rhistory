cnteven <- function(x) {
ecnt <- 0
ocnt <- 0
for(val in x){
#if(!is.na(val %% 2 ==0)&(val %% 2 ==0)) cnt <- cnt+1
if(val %% 2 == 0) {ecnt <- ecnt+1}
} else {ocnt <- ocnt+1}
print(ecnt)
}
#8-2
cnteven <- function(x) {
ecnt <- 0
ocnt <- 0
for(val in x){
#if(!is.na(val %% 2 ==0)&(val %% 2 ==0)) cnt <- cnt+1
ifelse(val %% 2 == 0, ecnt <- ecnt+1,ocnt <- ocnt+1)
}
print(ecnt)
}
cnteven(c(-5:5, Inf, -Inf, NA, NaN))
#8-2
cnteven <- function(x) {
ecnt <- 0
ocnt <- 0
for(val in x){
#if(!is.na(val %% 2 ==0)&(val %% 2 ==0)) cnt <- cnt+1
ifelse(val %% 2 == 0, ecnt <- ecnt+1, ocnt <- ocnt+1)
}
print(ecnt)
print(ocnt)
}
cnteven(c(-5:5, Inf, -Inf, NA, NaN))
length(c(-5:5, Inf, -Inf, NA, NaN))
#8-2
cnteven <- function(x) {
ecnt <- 0
ocnt <- 0
for(val in x){
#if(!is.na(val %% 2 ==0)&(val %% 2 ==0)) cnt <- cnt+1
ifelse(val %% 2 == 0, ecnt <- ecnt+1, ocnt <- ocnt+1)
print(ecnt)
print(ocnt)
}
}
cnteven(c(-5:5, Inf, -Inf, NA, NaN))
#8-2
cnteven <- function(x) {
ecnt <- 0
ocnt <- 0
for(val in x){
#if(!is.na(val %% 2 ==0)&(val %% 2 ==0)) cnt <- cnt+1
ifelse(val %% 2 == 0, ecnt <- ecnt+1, ocnt <- ocnt+1)
print('ecnt',ecnt)
print('ocnt',ocnt)
}
}
cnteven(c(-5:5, Inf, -Inf, NA, NaN))
#8-2
cnteven <- function(x) {
ecnt <- 0
ocnt <- 0
for(val in x){
#if(!is.na(val %% 2 ==0)&(val %% 2 ==0)) cnt <- cnt+1
ifelse(val %% 2 == 0, ecnt <- ecnt+1, ocnt <- ocnt+1)
print('ecnt :'+ecnt)
print('ocnt :'+ocnt)
}
}
cnteven(c(-5:5, Inf, -Inf, NA, NaN))
?print
#8-2
cnteven <- function(x) {
ecnt <- 0
ocnt <- 0
cnt <- 0
for(val in x){
cnt <- cnt+1
print(cnt)
#if(!is.na(val %% 2 ==0)&(val %% 2 ==0)) cnt <- cnt+1
ifelse(val %% 2 == 0, ecnt <- ecnt+1, ocnt <- ocnt+1)
print(ecnt)
print(ocnt)
}
}
cnteven(c(-5:5, Inf, -Inf, NA, NaN))
#8-3
test3 <- function(ifelse(x>pi, TRUE, FALSE))
#8-3
test3 <- function(ifelse(x > pi, TRUE, FALSE))
ifelse(x > pi, TRUE, FALSE)
#8-3
test3 <- function(x){
ifelse(x > pi, TRUE, FALSE)
}
test3(c(3, 1:5))
?norm
#8-4
norm4 <- function(x){
norm(x, na.rm=TRUE)
}
#8-4
norm4 <- function(x){
norm(x, na.rm=TRUE)
}
test4 <- c(1,2,3,4,5,NA)
norm4(test4)
?sd
#8-4
norm4 <- function(x){
x <- x[!is.na(x)]
z <- (x-mean(x))/sd(x)
}
test4 <- c(1,2,3,4,5,NA)
norm4(test4)
#8-4
norm4 <- function(x){
x <- x[!is.na(x)]
z <- (x-mean(x))/sd(x)
return(z)
}
norm4(test4)
?replace
sen5 <- 'I saw her standing there; Misery: Anna (Go to him); Chains; Boys; Ask me why'
sen5
?gsub
gsub(';','',sen5)
sen5 <- 'I saw her standing there; Misery; Anna (Go to him); Chains; Boys; Ask me why'
#8-5
remove5 <- function(x, rem=';',rep=''){
gsub(rem, rep, x)
}
remove5(sen5)
str(iris[1])
class(iris[1])
#8-6
printclass <- function(x){
if(is.data.frame(x)|is.matrix(x)){
for (i in 1:ncol(x)) cat(colnames(x)[i], 'is', class(x[,i]),'/n')
}
else cat("It's neither a data frame nor a matrix.",'/n')
}
printclass(iris)
#8-6
printclass <- function(x){
if(is.data.frame(x)|is.matrix(x)){
for (i in 1:ncol(x)) cat(colnames(x)[i], 'is', class(x[,i]),'\n')
}
else cat("It's neither a data frame nor a matrix.",'\n')
}
printclass(iris)
class(iris)
class(ncol(iris[1]))
class(ncol(iris[2]))
class(ncol(iris[5]))
class(ncol(iris[6]))
printclass(LakeHuron)
#8-7
function(x, med=FALSE){
mean=mean(x)
sd=sd(x)
med=median(x)
if(med!=TRUE){
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
} else {
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
cat('Also Median is', med,'\b.')
}
}
#8-7
fun7 <- function(x, med=FALSE){
mean=mean(x)
sd=sd(x)
med=median(x)
if(med!=TRUE){
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
} else {
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
cat('Also Median is', med,'\b.')
}
}
fun7(1:50)
fun7(1:50, med=TRUE)
#8-7
fun7 <- function(x, med=FALSE){
mean=mean(x)
sd=sd(x)
median=median(x)
if(med!=TRUE){
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
} else {
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
cat('Also Median is', median,'\b.')
}
}
fun7(1:50)
fun7(1:50, med=TRUE)
#8-7
fun7 <- function(x, med=FALSE){
mean=mean(x)
sd=sd(x)
median=median(x)
if(med!=TRUE){
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
} else {
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.\n')
cat('Also Median is', median,'\b.')
}
}
fun7(1:50)
fun7(1:50, med=TRUE)
#8-7
fun7 <- function(x, med=FALSE){
mean=round(mean(x, na.rm=TRUE),1)
sd=round(sd(x,na.rm = TRUE),1)
median=round(median(x,na.rm=TRUE),1)
if(med!=TRUE){
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.')
} else {
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.\n')
cat('Also Median is', median,'\b.')
}
}
fun7(1:50)
fun7(1:50, med=TRUE)
fun7 <- function(x, med=FALSE){
mean=round(mean(x, na.rm=TRUE),1)
sd=round(sd(x,na.rm = TRUE),1)
cat('Mean is',mean,'\b, and Standard Deviation is',sd,'\b.\n')
if(med==TRUE){
median=round(median(x,na.rm=TRUE),1)
cat('Also Median is', median,'\b.')
}
}
fun7(1:50, med=TRUE)
fun7(1:50)
lst2 <- list(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
lst2
#문자가 있으면 전체가 다 문자로 바뀜
unlist(lst2)
#matrix 만들기 리스트를 벡터로 바꾸고 다음에 matrix로 변환해야함
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
#matrix 만들기 리스트를 벡터로 바꾸고 다음에 matrix로 변환해야함
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
lst
#matrix 만들기 리스트를 벡터로 바꾸고 다음에 matrix로 변환해야함
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
matrix(lst)
as.matrix(lst)
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
matrix(lst)
as.data.frame(lst) #숫자 문자 섞여서 상관없음
as.data.frame(lst2)
str(as.data.frame(lst2))
as.numeric("gold")
as.numeric(c("-1","1.414", "3.14"))
as.numeric(c("-1","1.414", "3.14", "and"))
as.character(11:15)
as.numeric(TRUE)
as.numeric(FALSE)
#vector
vec <- 1:6
as.list(vec)
list(vec)
#하나의 열을 가진 행렬 만들기
cbind(vec)
rbind(vec)
as.data.frame(vec)
as.data.frame(rbind(vec))
#matrix
mat <- matrix(1:6, 2,3)
mat
as.vector(mat)
as.list(mat)
list(mat)
as.data.frame(mat)
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
lst
unlist(lst)
as.vector(lst)
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
install.packages("quantmod")
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
#install.packages("quantmod")
#finance.yahoo.com에서 가져옴
#finance.yahoo.com: Samsung Electronics(005930.ks), KRW 개별 종목의 코드, 환율
library(quantmod)
sec <- getSymbols(Symbols = "005930.ks",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
sec <- as.data.frame(sec)
str(sec)
head(sec)
head(sec[c("005930.KS.Close", "005930.KS.Volume")])
sec <- cbind(date=rownames(sec),
symbol="005930.KS",
sec[c("005930.KS.Close", "005930.KS.Volume")])
rownames(sec) <- NULL #행이름 지우기
colnames(sec)[c(3,4)] <- c("close", "volume")
head(sec)
#현대자동차 주가정보 다운로드
hmc <- getSymbols(Symbols = "005387.KS",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
hmc <- as.data.frame(hmc)
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
hmc[c("005387.KS.Close", "005387.KS.Volume")])
rownames(hmc) <- NULL
colnames(hmc)[c(3,4)] <- c("close", "volume")
#행의 방향으로 결함
stock <- rbind(sec, hmc)
head(stock)
#현대자동차 주가정보 다운로드
hmc <- getSymbols(Symbols = "005387.KS",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
hmc <- as.data.frame(hmc)
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
hmc[c("005387.KS.Close", "005387.KS.Volume")])
rownames(hmc) <- NULL
colnames(hmc)[c(3,4)] <- c("close", "volume")
#행의 방향으로 결함
stock <- rbind(sec, hmc)
head(stock)
stock
#데이터프레임 형태로 변환
fx <- as.data.frame(fx)
#merge로 환율 데이터 옆에 붙이기
#finance.yahoo.com
fx <- getSymbols(Symbols = "KRW=X",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
#데이터프레임 형태로 변환
fx <- as.data.frame(fx)
str(fx)
head(fx["KRW=X.Close"])
fx <- cbind(date=rownames(fx),
fx[c("KRW=X.Close")])
head(fx)
rownames(fx) <- NULL
colnames(fx)[c(2)] <- "close"
#공통된 날짜 기준으로 merge
#공통 열 이름 확인
intersect(names(sec), names(fx))
report <- merge(sec, fx, by="date")
report
head(mtcars)
car <- mtcars
car["name"] <- rownames(car)
rownames(car) <- NULL
head(car)
highhp.car <- car[car$hp>145,]
highhp.car
lightwt.car <- car[car$wt<3.2,]
lightwt.car
#힘이 좋으면서 가벼운 차 위의 2dataframe 합치기
index <- match(highhp.car$name, lightwt.car$name)
index
lightwt.car[na.omit(index),]
index2 <- highhp.car$name %in% lightwt.car$name
index2
highhp.car[index2,]
#week11-1
#sort
x <- c(3,7,5,1,2,5)
sort(x)
sort(x, decreasing = TRUE)
#NA가 포함되어 있는 경우, NA는 출력되지 않음
length(x) <- 7
x
sort(x)
sort(x, na.last = TRUE)#NA가 가장 뒤에 위치
sort(x, na.last = FALSE)#NA가 가장 앞에 위치
#벡터 자체를 소팅하지 않음. 소팅되었을 때 인덱스를 출력함
y <- c(33,11,55,22,44)
order(y)
y[order(y)]
sort(y)
y <- c(33,11,55,22,44)
z <- c("Superman","Batman","Ironman","Antman","Spiderman")
df <- data.frame(y,z)
df
#y열 기준
order(df$y)
df[order(df$y),]
#내림차순
df[order(df$y,decreasing=TRUE),]
df[order(-df$y),]
y <- c(33,11,55,22,44)
z <- c("Superman","Batman","Ironman","Antman","Spiderman")
w <- c("can fly", "can not fly","can fly","cannot fly","can fly")
df <- data.frame(y,z,w)
df
df[order(df$w, df$y),]
#각 열마다 다르게 소팅하고 싶은 경우
#install.packages("dplyr")
library(dplyr)
df[order(desc(df$w),y),]
df[order(-df$w,y),]
head(mtcars)
g <- split(mtcars$mpg, f=mtcars$am)
g
mean(g[[1]])
mean(g[["Manual"]])
#am 변수를 가지고 집단으로 만들어봄
cars <- within(mtcars,
am <- factor(am,
levels = c(0,1),
labels = c("Automatic","Manual")))
head(cars)
head(mtcars)
g <- split(mtcars$mpg, f=mtcars$am)
g
g <- split(cars$mpg, f=cars$am)
g
mean(g[[1]])
mean(g[["Manual"]])
sapply(g,mean)
#처리할 벡터, 집단을 나타내는 팩터, 적용할 함수 3가지 인자 받음
tapply(X=iris$Sepal.Length, INDEX = iris$Species, FUN=mean)
tapply(X=iris$Sepal.Length, INDEX = iris$Species, FUN=length)
str(mtcars)
with(mtcars,tapply(mpg, list(cyl ,am), mean))
tapply(mtcars$mpg, list(mtcars$cyl ,mtcars$am), mean)
with(mtcars,
aggregate(x=mpg, by=list(Cylincer=cyl ,Transmission=am),
FUN=mean))
aggregate(mtcars[1:6], list(Group.cyl=mtcars$cyl ,Group.am=mtcars$am),
FUN=mean)
aggregate(iris[1:4], list(Species=iris$Species), mean)
tapply(mtcars[1:6], INDEX=list(mtcars$cyl ,mtcars$am), mean)
aggregate(iris[1:4], list(Species=iris$Species), mean)
by(data=iris[1:4], INDICES = iris$Species, FUN=mean)
by(data=iris, INDICES = iris$Species, FUN=mean)
aggregate(iris[1:4], list(Species=iris$Species), mean)
by(data=iris, INDICES = iris$Species, function(x) mean(x$Sepal.Length))
rowsum(iris[-5], iris$Species)
#범주형 변수가 주어지면 변수가 몇개인가 알려줌
table(mtcars$gear)
table(mtcars$am)
table(mtcars$am, mtcars$gear)
#균일한 구간으로 나눔
mpg.cut <- cut(mtcars$mpg, breaks = 5)
#범주형 변수가 주어지면 변수가 몇개인가 알려줌
table(mpg.cut)
#tapply(mtcars$mpg, list(mtcars$cyl ,mtcars$am), mean)
with(mtcars,tapply(mpg, list(Cylincer=cyl ,Transmission=am), mean))
xtabs(formula = ~am+gear, data=mtcars)
aggregate(formula=mpg~cyl+am, data=mtcars, FUN=mean)
library(stringr)
str_subset(airquality, subset=(Month==6))
?str_subset
if(flip()=='H'){
nhead <- nhead+1
} else{
nhead <- 0
}
unique(airquality$Month)
#중복되지 않는 값 출력
distinct(select(airquality, Month))
?dplyr
?arrange
with(airquality, order(Temp,Month,Day))
#여러 열을 지정가능 순서대로 arrange됨, 오름차순
arrange(airquality, Temp, Month, Day)
#여러 열을 지정가능 순서대로 arrange됨, 오름차순
arrange(airquality, Temp, Month, Day)
order(airquality$Temp,airquality$Month,airquality$Day))
order(airquality$Temp,airquality$Month,airquality$Day)
airquality[order(airquality$Temp,airquality$Month,airquality$Day)]
airquality[order(airquality$Temp,airquality$Month,airquality$Day),]
with(airquality, airquality[order(Temp,Month,Day),])
#
air.group <- group_by(airquality, Month)
air.group
summarise(air.group,
Mean.Temp=mean(Temp, na.rm=TRUE),
sd.Temp=sd(Temp, na.rm = TRUE),
Days=n())
#pipe operator 사용해서 똑같이 해보기
air <- airquality %>%
select( Ozone, Temp, Month) %>%
group_by(Month) %>%
summarise(Mean.ozone=mean(Ozone,na.rm=TRUE),
Mean.Temp=mean(Temp, na.rm=TRUE)) %>%
filter(Mean.ozone>40 | Mean.Temp>80)
air
#by 인수를 지정
inner_join(band_members, band_instruments, by="name")
flights  %>%
count(flights, flights$dest)
library(nycflights13)
flights  %>%
count(flights, flights$dest)
str(flights)
flights  %>%
count(flights[,'dest'], flights$dest)
