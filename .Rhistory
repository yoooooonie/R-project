<<<<<<< HEAD
openFileInOS("product.txt")
read_table(file = "product.csv",
col_names = c('id','name','price'))
read_table(file = "product.txt",
col_names = c('id','name','price'))
openFileInOS("word.txt")
read_lines(file="word.txt")
#원하는 라인만 읽음
read_lines(file="word.txt", skip=1, nmax=3)
#원하는 라인만 읽음
read_lines(file="word.txt", skip=1, n_max=3)
#라인단위로 읽어올 수 있음
openFileInOS("word.txt")
read_file(file = "word.txt")
Orange
write_csv(x=Orange, file = "orange.csv")
read_csv(file="orange.csv")
write_delim(x=Orange, file = "orange2.txt", delim=";")
read_delim(file='orange2.txt', delim = ";")
#저장하기
write_lines(x=Orange$circumference, file = 'c.txt')
read_lines("c.txt")
#숫자의 앞이나 뒤에 있는 문자를 제거하고 숫자로 반환
parse_number("$100")
class(parse_number("$100"))
parse_number("30%")
parse_number("60.5Kg")
parse_number("Salary per year : $200,000")
parse_number("Salary per year : $20,000")
parse_number("Salary per year : $25,000")
parse_number("Salary per year : $25000")
parse_number("Salary per year : $2500,000")
parse_number("Salary per year : $250,000")
return(result)
#함수
transLength <- function(x){
tlength <- round(x*0.9144, digits = 1)
result <- paste(tlength, "m", sep="")
return(result)
}
ls()
y <- c(100,150,200)
transLength(y)
#R에서는 함수역시 객체이다 다른 객체에 할당함으로 복사 가능
trans2 <- transLength
trans2
trans2(y)
#return 없애고 적재하면 리턴 값 없음
transLength <- function(x){
tlength <- round(x*0.9144, digits = 1)
result <- paste(tlength, "m", sep="")
}
transLength(y)
print(transLength(y))
#숫자가 아닌경우 종료하기 추가
transLength <- function(x){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*0.9144, digits = 1)
paste(tlength, "m", sep="")
}
transLength("ABC")
#함수 만들어 보기
f1 <- function(x,y) {x+y}
f2 <- function(x,y) x+y
f1(1,3)
f2(1,3)
transLength <- function(x) paste(round(x*0.9144, digits = 1),"m", sep="")
transLength(y)
#길이변환 함수 만들기
transLength <- function(x, multi, unit){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, digits = 1)
paste(tlength, unit, sep="")
}
transLength(y, multi=3, unit="ft")
transLength(y, multi=36, unit="inch")
transLength(y)
tlength <- round(x*multi, digits = 1)
#초기값 설정
transLength <- function(x, multi=0.9144, unit="m"){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, digits = 1)
paste(tlength, unit, sep="")
}
transLength(y)
transLength(y, multi=3, unit="ft")
#내부함수 사용하는 인수들 정할 수 있다
transLength <- function(x, multi=0.9144, unit="m", ...){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, ...)
paste(tlength, unit, sep="")
}
transLength(y, digits=2)
transLength(y)
tlength <- round(x*multi, digits = digits)
#내부함수 인수 초기화
transLength <- function(x, multi=0.9144, unit="m", digits=1){
if(!is.numeric(x)) return("Not a Number")
tlength <- round(x*multi, digits = digits)
paste(tlength, unit, sep="")
}
transLength(y)
#내부함수에 초기 함수를 설정할 수 있음
transLength <- function(x, multi=0.9144, unit="m", FUN=round, ...){
tlength <- FUN(x*multi, ...)
paste(tlength, unit, sep="")
}
transLength(y)
transLength(y, FUN=signif, digits = 3)
transLength(y, FUN=floor)
ls()
x <- 11:15
scopetest <- function(x){
cat("This is x :", x, "\n")
rm(x)
cat("This is after removing x", x, "\n")
}
scopetest(x=15:11)
#논리흐름 제어
x <- pi
y <- 3
if(x>y) x
if(x<y) x
if(x<y) x else y
if(x>y) x else y
#벡터는 조건문에 들어갈 수 없고, 들어가더라도 처음 인자만 조건에 들어감
x <- pi
y <- 1:5
if(x<y) x else y
if(x>y) x else y
#벡터 연산을 통해서
test <- c(TRUE, FALSE, TRUE, TRUE, FALSE )
yes <- 1:5
no <- 0
ifelse(test, yes, no)
x>y
ifelse(x>y, x , y)
#첫번째 조건에 따라 2번째 이후 수행
center <- function(x, type){
swtich(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1)
)
}
x <- c(2,3,5,7,11,13,17,19,23,29)
center(x, "mean")
switch(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1)#절삭평균
)
#첫번째 조건에 따라 2번째 이후 수행
center <- function(x, type){
switch(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1)#절삭평균
)
}
center(x, "mean")
center(x, "median")
center(x, "trimmed")
center <- function(x, type){
switch(type,
mean=mean(x),
median=median(x),
trimmed=mean(x, trim=0.1),#절삭평균
"Choose one of mean, median, trimmed."
)
}
center(x, "other")
repeat print("hello")
i <- 5
repeat {if(i>25) break
else {print(i)
i <- i+5}
}
i <- 5
while(i<=25){
print(i)
i <- i + 5
}
#for (var in list) statement
for (i in seq(from=5, to=25, by=5)) print(i)
for  (i in seq(from=5, to=25, by=5)) i
i <- 1
for  (i in seq(from=5, to=25, by=5)) i
i
mode(1.414)
mode(c(1:3))
mode("Batman")
mode(c("Batman", "Superman","Spiderman"))
mode(factor("High","Medium","Low"))
mode(as.Date("2030-12-31"))
mode(5>2)
mode(list(1.23, "Apple",c(2,3,4,5)))
mode(data.frame(x=1:3, y=c("H","M","L")))
mode(mean)
#class 숫자로는 물리적으로 하나의 형태로 저장되더라도 동시에 여러개로 나타날 수 있다
d <- as.Date("2030-12-31")
mode(d)
length(d)
class(d)
#class가 date 이기 때문에 일반 숫자가 아니라 날짜로 인지한다
as.integer(d)
d+1
methods(print)
#변환이 불가하면 NA 출력
as.numeric(1.414)
as.integer(1.414)
as.character(1.414)
as.numeric("gold")
as.numeric(c("-1","1.414", "3.14"))
as.numeric(c("-1","1.414", "3.14", "and"))
as.character(11:15)
as.numeric(TRUE)
as.numeric(FALSE)
#vector
vec <- 1:6
vec
as.list(vec)
list(vec)
#하나의 열을 가진 행렬 만들기
cbind(vec)
as.matrix(vec)
rbind(vec)
matrix(vec, 2,3)
as.data.frame(vec)
as.data.frame(rbind(vec))
#matrix
mat <- matrix(1:6, 2,3)
mat
as.vector(mat)
as.list(mat)
list(mat)
as.data.frame(mat)
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
lst
unlist(lst)
as.vector(lst)
as.vector(unlist(lst))
lst <- list(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
lst
unlist(lst)
lst2 <- list(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
lst2
#문자가 있으면 전체가 다 문자로 바뀜
unlist(lst2)
matrix(lst2)
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst))
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
unlist(lst)
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
matrix(lst)
as.matrix(lst)
as.data.frame(lst)
as.data.frame(lst2)
str(as.data.frame(lst2))
#data frame
dfm <- data.frame(odd=c(1,3,5), even=c(2,4,6))
dfm
dfm[,1]
dfm[[1]]
str(dfm[,1])
str(dfm[[1]])
dfm[1,]
str(dfm[1,])
as.matrix(dfm)
as.vector(as.matrix(dfm))
dfm2 <- data.frame(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
dfm2
as.vector(as.matrix(dfm2))
#dataframe->list
as.list(dfm2)
as.matrix(dfm2)
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
install.packages("quantmod")
#각 열마다 다르게 소팅하고 싶은 경우
install.packages("dplyr")
#purr map()
install.packages("purrr")
#reshape2
install.packages("reshape2")
#week12 형태변환
#tidyr- gather(), spread()
install.packages("tidyr")
#reduce
library(purrr)
#1,3에 적용 다음 5에 적용 다음 7에 적용
reduce(.x=c(1,3,5,7), .f=`*`) #연산자는 백틱? esc 아래키로 감싸서 사용
paste2 <- function(u,v,sep=".") paste(u, v, sep=sep)
letters[1:4] %>%
reduce(paste2)
#group by
head(mtcars)
library(dplyr)
mtcars.n <- mtcars %>%
group_by(cyl) %>%
nest()
library(dplyr)
mtcars.n <- mtcars %>%
group_by(cyl) %>%
nest()
library(tidyr)
mtcars.n <- mtcars %>%
group_by(cyl) %>%
nest()
mtcars.n <- mtcars %>%
group_by(cyl) %>%
nest()
mtcars.n
#pivot_longer(), pivot_wider() #tibble 형태로 됨
head(airquality)
aq.long <- pivot_longer(airquality,
cols = Ozone:Temp,
names_to = "Factor",
values_to = "Measurement")
head(aq.long)
Sepal.Length+Petal.Length
#Part2 데이터 전처리
#2장
trasform(iris, Sum.Length=Sepal.Length+Petal.Length)
iris
iris
transform(iris, Sum.Length=Sepal.Length+Petal.Length)
student_id <- ("s1","s2","s3")
student_id <- c("s1","s2","s3")
score <- c(55,90,85)
df <- data.frame(student_id,score)
?within
df <- within(df,{
grade[score<60]="가"
grade[score>=60 & score<70]="양"
grade[score>=70 & score<80]="미"
grade[score>=80 & score<90]="우"
grade[score>=100]="수"
grade=factor(grade, level=c("수","우","미","양","가"))
} )
grade[score<60] <- "가"
grade <- factor(grade, level=c("수","우","미","양","가"))
df <- within(df,{
grade[score<60] <- "가"
grade[score>=60 & score<70] <- "양"
grade[score>=70 & score<80] <- "미"
grade[score>=80 & score<90] <- "우"
grade[score>=100] <- "수"
#  grade <- factor(grade, level=c("수","우","미","양","가"))
} )
grade = factor(grade, level=c("수","우","미","양","가"))
df.ya <- within(df,{grade="ya"})
df.ya
df.ya <- within(df,{grade[score<60] = "가"})
df.ya <- within(df,{df[score<60] = "가"})
df.ya
df.ya <- within(df,{df$grade[score<60] = "가"})
df.ya
df$grade = factor(grade, level=c("수","우","미","양","가"))
df <- within(df,{
df$grade=character(0)
df$grade[score<60] = "가"
df$grade[score>=60 & score<70] = "양"
df$grade[score>=70 & score<80] = "미"
df$grade[score>=80 & score<90] = "우"
df$grade[score>=100] = "수"
df$grade = factor(grade, level=c("수","우","미","양","가"))
} )
df <- within(df,{
df$grade=character(0)
df$grade[score<60] = "가"
df$grade[score>=60 & score<70] = "양"
df$grade[score>=70 & score<80] = "미"
df$grade[score>=80 & score<90] = "우"
df$grade[score>=100] = "수"
df$grade = factor(grade, level=c("수","우","미","양","가"))
} )
df$grade[score<60] = "가"
df <- within(df,{
df$grade[score<60] = "가"
df$grade[score>=60 & score<70] = "양"
df$grade[score>=70 & score<80] = "미"
df$grade[score>=80 & score<90] = "우"
df$grade[score>=100] = "수"
df$grade = factor(grade, level=c("수","우","미","양","가"))
} )
df
df <- data.frame(student_id,score)
df
df$grade <- factor(grade, level=c("수","우","미","양","가"))
df
df <- within(df,{
df$grade[score<60] = "가"
df$grade[score>=60 & score<70] = "양"
df$grade[score>=70 & score<80] = "미"
df$grade[score>=80 & score<90] = "우"
df$grade[score>=100] = "수"
df$grade = factor(grade, level=c("수","우","미","양","가"))
} )
library(dataset)
data("USArrests")
head(USArrests)
#산점도를 통해 변수 간 상관관계 파악
pairs(USArrests, panel=panel.smooth, main="USArrests data")
#주성분분석 수행
US.prin <- princomp(USArrests, cor=TRUE)
summary(US.prin)
#screeplot그리기
plot(US.prin, type='l')
US.prin$loadings
#주성분점수
head(US.prin)
str(US.prin)
#주성분점수
US.prin$scores
#제1-2주성분에 의한 행렬도
biplot(US.prin, scale=0)
#변수축소-2
#요인분석#p65
data(swiss)
str(swiss)
#정규화 수행 및 실습 데이터 생성
Min <- apply(swiss, 2, min)
Max <- apply(swiss, 2, max)
swiss.fa <- scale(swiss, center=Min, scale=(Max-Min))
head(swiss.fa)
#요인분석 factor=3으로 줌 rotation인자는 기본값 varimax
factanal(swiss.fa, factors = 3)
#예제
head(mtcars)
test.cars <- data.frame(mtcars$mpg,mtcars$hp)
head(test.cars)
test.cars <- transform(test.cars,
mpg.scale=scale(test.cars$mtcars.mpg),
hp.scale=scale(test.cars$mtcars.hp))
heatd(test.cars)
head(test.cars)
#test.cars <- data.frame(mtcars$mpg,mtcars$hp)
#위처럼 하면 행이름이 없어짐
test.cars <- mtcars[,c("mpg","hp")]
head(test.cars)
test.cars <- transform(test.cars,
mpg.scale=scale(test.cars$mtcars.mpg),
hp.scale=scale(test.cars$mtcars.hp))
#test.cars <- data.frame(mtcars$mpg,mtcars$hp)
#위처럼 하면 행이름이 없어짐
test.cars <- mtcars[,c("mpg","hp")]
head(test.cars)
test.cars <- transform(test.cars,
mpg.scale=scale(test.cars$mtcars.mpg),
hp.scale=scale(test.cars$mtcars.hp))
transform(test.cars,
mpg.scale=scale(test.cars$mtcars.mpg),
hp.scale=scale(test.cars$mtcars.hp))
test.cars <- data.frame(mtcars$mpg,mtcars$hp)
head(test.cars)
test.cars <- transform(test.cars,
mpg.scale=scale(test.cars$mtcars.mpg),
hp.scale=scale(test.cars$mtcars.hp))
head(test.cars)
test.cars <- mtcars[,c("mpg","hp")]
head(test.cars)
test.cars <- transform(test.cars,
mpg.scale=scale(test.cars$mpg),
hp.scale=scale(test.cars$hp))
head(test.cars)
#정규화 일반적으로 min-max
Min <- min(iris$Sepal.Length)
Max <- max(iris$Sepal.Length)
iris$SL.new <- scale(iris$Sepal.Length, center = Min, scale = Max-Min)
head(iris$SL.new)
head(iris)
Datetime <- data.frame('12/25/2030 23:59:59', '1/25/2031 23:59:59', '2/25/2031 23:59:59')
Datetime
a <- '12/25/2030 23:59:59'
as.POSIXct(a, format='%d/%m/%Y %H:%M:%S')
a <- '12/25/2030 23:59:59'
as.POSIXct(a, format='%d/%m/%Y %H:%M:%S')
pct <- as.POSIXct("2025/03/15, 15:03:04",
format="%Y/%m/%d, %H:%M:%S")
pct
as.POSIXct(a, format="%d/%m/%Y %H:%M:%S")
?strptime
as.POSIXct(a, format="%m/%d/%Y %H:%M:%S")
Datetime <- data.frame('12/25/2030 23:59:59', '1/25/2031 23:59:59', '2/25/2031 23:59:59')
Datetime
pct <- as.POSIXct(Datetime,
format='%m/%d/%Y %H:%M:%S')
with(Datetime, as.POSIXct(format='%m/%d/%Y %H:%M:%S'))
with(Datetime, as.POSIXct(Datetime, format='%m/%d/%Y %H:%M:%S'))
df$Datetime <- data.frame('12/25/2030 23:59:59', '1/25/2031 23:59:59', '2/25/2031 23:59:59')
df$Datetime
df$Datetime <- data.frame('12/25/2030 23:59:59', '1/25/2031 23:59:59', '2/25/2031 23:59:59')
df$Datetime <- data.frame(Datetime='12/25/2030 23:59:59', '1/25/2031 23:59:59', '2/25/2031 23:59:59')
df$Datetime <- data.frame(Datetime=c('12/25/2030 23:59:59', '1/25/2031 23:59:59', '2/25/2031 23:59:59'))
df$Datetime
as.POSIXct(df$Datetime,
format='%m/%d/%Y %H:%M:%S')
df$Datetime <- strptime(df$Datetime,
format='%m/%d/%Y %H:%M:%S')
df$Datetime
df
gc()
gc()
=======
legend=TRUE,
ylab = "Survivors", las=1, ylim=c(0,1000),
main="Grouped Bar Chart")
#범례위치 바꾸기
barplot(survival.by.class, beside = TRUE,
names.arg = c("1st Class", "2nd Class", "3rd Class", "Crew"),
cex.names = 0.75,#크기
col = c("red", "green"),#색깔
ylab = "Survivors", las=1, ylim=c(0,1000),
main="Grouped Bar Chart")
legend(x=1,y=900)
legend(x=1,y=900, legend = c("Dead", "Alive"))
legend(x=1,y=900, legend = c("Dead", "Alive"),
#pch= ,모양인경우
#lty = ,선 인 경우
fill = c("red", "green"), title = "Status")
#막대의 높이를 동일하게 만들고 척도 비교하기
survival.by.class
survival.prop <- prop.table(survival.by.class, margin=2) #열의 비율을 계산해서 margin=2
survival.prop
barplot(survival.prop, col=c("maroon", "skyblue"),
xlab="Class", ylab="Ratio of Survivors", las=1,
main="Survivors by Class(Ratio")
install.packages("vdc")
#install.packages("vdc")
library(vdc)
install.packages("vcd")
library(vcd)
spine(t(survival.by.class), gp=gpar(fill=c("mistyrose", "lightblue")),
main="Spine Plot of Survivors by Class") #t()로 행과열을 바꾸고 인자로 넘긴다
#수직누적막대도표
survival.by.class <- margin.table(Titanic, margin=c(4,1))
survival.by.class
spine(t(survival.by.class), gp=gpar(fill=c("mistyrose", "lightblue")),
main="Spine Plot of Survivors by Class") #t()로 행과열을 바꾸고 인자로 넘긴다
str(chickwts)
heights <- tapply(chickwts$weight, chickwts$feed, mean)
heights
barplot(heights, xlab="Feed Type", ylab="Mean Chichen Weights(g)",
ylim=c(0,400), las=1, main="Chicken Weights by Feed Type")
#막대도표 꾸미는 옵션들 살펴보기
str(UCBAdmissions)
admission.by.dept <- margin.table(UCBAdmissions, c(1,3))
admission.by.dept
barplot(admission.by.dept, density = 15, angle = 135)#density = 인치당 사선의 개수 , angle = 사선의 각도
barplot(admission.by.dept, density = 55, angle = 45)#density = 인치당 사선의 개수 , angle = 사선의 각도
barplot(admission.by.dept, border = "red", col=c("lightblue", "mistyrose"))#
#수평으로 만들기
barplot(admission.by.dept, beside=TRUE, space = c(0.3,2.0)) #막대간 간격, 집단간 간격, 기본0 or 1
barplot(admission.by.dept, beside=TRUE, space = c(0.1,3.0)) #막대간 간격, 집단간 간격, 기본0 or 1
barplot(admission.by.dept, axes = FALSE) #수직 좌표축이 출력되지 않음음
barplot(admission.by.dept, horiz=TRUE, axes = FALSE)
#히스토그램
str(iris)
#꽃받침 폭에 따른 히스토그램
hist(iris$Sepal.Width)
hist(iris$Sepal.Width, main = "Sepal.Width")
hist(iris$Sepal.Width, main = "Sepal.Width", las=1)
?hist
hist(iris$Sepal.Width, main = "Sepal.Width", las=1, breaks=20)#breaks 구간의 개수 설정. 100% 맞진 않지만 맞추려고 함
seq(2.0,4.4,0.2)
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2))
#labels 값 보이기
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE)
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE,
density = 50, angle = 100)#density = 인치당 사선의 개수 , angle = 사선의 각도
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE,
density = 50, angle = 100,#density = 인치당 사선의 개수 , angle = 사선의 각도
xlim = c(2,4.5), ylim = c(0,40)
)
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE,
density = 50, angle = 100,#density = 인치당 사선의 개수 , angle = 사선의 각도
xlim = c(2,4.5), ylim = c(0,40),
xlab = "Sepal Width(Cm)"
)
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE,
density = 50, angle = 100,#density = 인치당 사선의 개수 , angle = 사선의 각도
xlim = c(2,max(iris$Sepal.Width)), ylim = c(0,40),
xlab = "Sepal Width(Cm)"
)
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE,
density = 50, angle = 100,#density = 인치당 사선의 개수 , angle = 사선의 각도
xlim = c(2,max(iris$Sepal.Width)), ylim = c(0,max(iris$Sepal.Width)),
xlab = "Sepal Width(Cm)"
)
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE, prob=TRUE,
col="gold", border="red",
density = 50, angle = 100,#density = 인치당 사선의 개수 , angle = 사선의 각도
xlim = c(2,4.5), ylim = c(0,40),
xlab = "Sepal Width(Cm)"
)
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE, prob=TRUE,#prob:확률
col="gold", border="red",
xlim = c(2,4.5), ylim = c(0,1.5),
xlab = "Sepal Width(Cm)"
)
density(iris$Sepal.Width)
lines(density(iris$Sepal.Width), col="black", lwd=2)
quantile(iris$Sepal.Width)
rug(quantile(iris$Sepal.Width), col="purple", lwd=1)
rug(quantile(iris$Sepal.Width), col="purple", lwd=4)
#정규분포곡선 추가해서 그리기
hist(iris$Sepal.Width, breaks=seq(2.0,4.4,0.2), labels = TRUE, prob=TRUE, #prob:확률밀도함수로 볼 수 있음
col="gold", border="red",
xlim = c(2,4.5), ylim = c(0,1.5),
xlab = "Sepal Width(Cm)"
)
x <- seq(min(iris$Sepal.Width), max(iris$Sepal.Width), length=40)
y <- dnorm(x, mean =mean(iris$Sepal.Width) , sd=sd(iris$Sepal.Width))
lines(x,y, col="chocolate", lwd=3)
#
box()
iris()
str(iris)
ds <- density(iris$Sepal.Width)
plot(ds)
plot(ds, main="Density of Sepal Width")
polygon(ds, col="pink", border = "red")
rug(iris$Sepal.Width, col="purple")
install.packages("sm")
#install.packages("sm")
library(sm)
attach(iris)
sm.density.compare(x=Sepal.Width, group = Species,
xlab="Sepal Width(Cm)")
title(main="Distribution of Sepal Width by Iris Species", col="purple")
title(main="Distribution of Sepal Width by Iris Species", col="purple")
lty = c("solid", "dashed", "dotted"), col=c("red", "grren", "blue")
legend("topright", legend = levels(Species),
lty = c("solid", "dashed", "dotted"), col=c("red", "grren", "blue"))
legend("topright", legend = levels(Species),
lty = c("solid", "dashed", "dotted"), col=c("red", "green", "blue"))
legend("topright", legend = levels(Species),
lty = c("solid", "dashed", "dotted"), col=c("red", "green3", "blue"))
#상자도표
str(iris)
boxplot(iris$Sepal.Width)
boxplot(iris$Sepal.Width,
ylab="Sepal Width", main="Sepal Width of Iris", las=1)
#whisker:수염, box and whisker plot 박스 수염 도표
#이상점은 동그라미도 표현됨
boxplot.stats(iris$Sepal.Width)
boxplot(Sepal.Width~Species, data=iris,
ylab="Sepal width", main="Sepal width of Iris Species")
?boxplot
boxplot(Sepal.Width~Species, data=iris,
notch=TRUE,border="red",
col=c("pink", "purple","lightblue"),
ylab="Sepal width", main="Sepal width of Iris Species")
boxplot(Sepal.Width~Species, data=iris,
notch=TRUE,border="red", las=1,
col=c("pink", "purple","lightblue"),
ylab="Sepal width", main="Sepal width of Iris Species")
boxplot(Sepal.Width~Species, data=iris,
notch=TRUE,border="red", las=1, #notch 95프로 신뢰구간이 v홈으로 파이는게 보인다
col=c("pink", "purple","lightblue"),
names=c("Setosa", "Versicolor", "Virginica"), #이름 설정 가능
ylab="Sepal width", xlab="", main="Sepal width of Iris Species")
#가로로 그리기
boxplot(Sepal.Width~Species, data=iris, horizontal = TRUE, #가로로 그리기, xlab,ylab 을 바꿔줘야 함
notch=TRUE,border="red", las=1, #notch 95프로 신뢰구간이 v홈으로 파이는게 보인다
col=c("pink", "purple","lightblue"),
names=c("Setosa", "Versicolor", "Virginica"), #이름 설정 가능
xlab="Sepal width", ylab="", main="Sepal width of Iris Species")
#집단을 구분하는 변수가 여러개인 경우
str(mtcars)
#cyl, am factor로 변환
mtcars$cyl.factor <- factor(mtcars$cyl,
levels = c(4,6,8), labels = c("4", "6","8"))
mtcars$am.factor <- factor(mtcars$am,
levels = c(0,1), labels = c("Auto","Manual"))
boxplot(mpg~am.factor*cyl.factor, data=mtcars)
boxplot(mpg~am.factor*cyl.factor, data=mtcars,
col=c("salmon","violet"), las=1,
xlab="Car Type", ylab="Milers per Gallon",
main="Car Mileage by Type")
boxplot(mpg~am.factor*cyl.factor, data=mtcars,
col=c("salmon","violet"), las=1,
varwidth=True,
xlab="Car Type", ylab="Milers per Gallon",
main="Car Mileage by Type")
boxplot(mpg~am.factor*cyl.factor, data=mtcars,
col=c("salmon","violet"), las=1,
varwidth=TRUE,
xlab="Car Type", ylab="Milers per Gallon",
main="Car Mileage by Type")
boxplot(mpg~am.factor*cyl.factor, data=mtcars,
col=c("salmon","violet"), las=1,
varwidth=TRUE, #표본의 크기를 비교해서 볼 수 있다.
at=c(1,2, 3.5,4.5, 6,7), #사이의 간격 위치로 지정
xlab="Car Type", ylab="Milers per Gallon",
main="Car Mileage by Type")
windows(width = 12, height = 8)
boxplot(mpg~am.factor*cyl.factor, data=mtcars,
col=c("salmon","violet"), las=1,
varwidth=TRUE, #표본의 크기를 비교해서 볼 수 있다.
at=c(1,2, 3.5,4.5, 6,7), #사이의 간격 위치로 지정
xlab="Car Type", ylab="Milers per Gallon",
main="Car Mileage by Type")
#바이올린도표 상자도표+밀도도표
str(mtcars)
View(mtcars)
library(vioplot)
install.packages("vioplot")
#바이올린도표 : 상자도표+밀도도표
#install.packages("vioplot")
library(vioplot)
str(mtcars)
mtcars <- mtcars[,0:-2]
str(mtcars)
#바이올린도표 : 상자도표+밀도도표
#install.packages("vioplot")
library(vioplot)
str(mtcars)
mtcars2 <-
head(mtcars)
;;;
mtcars2 <-
head(mtcars)
head(mtcars)
mtcars2 <- mtcars[,0:-2]
head(mtcars2)
mtcars2 <- mtcars[,0:length(mtcars)-2]
str(mtcars)
head(mtcars)
mtcars2 <- mtcars[0:-2]
head(mtcars2)
mtcars2 <- mtcars[-2]
head(mtcars2)
head(mtcars)
mtcars2 <- mtcars[-2]
head(mtcars2)
head(mtcars)
mtcars2 <- mtcars[,1:-2]
mtcars2 <- mtcars[,1:-2]
mtcars2 <- mtcars[1:-2]
matrix(1:12, 3,4)
a <- matrix(1:12, 3,4)
a[,1:3]
a[,1:-1]
a[,-2]
a[,1:col(a)-1]
a[,1:length(a)-1]
length(a)
a <- data.frame(1:12, 3,4)
a[,1:length(a)-1]
a
a <- data.frame(1:12, 3,4)
a
a[,1:length(a)-1]
mtcars2 <- mtcars[,length(mtcars)-2]
head(mtcars2)
head(mtcars)
length(mtcars)-2
mtcars2 <- mtcars[,1:length(mtcars)-2]
length(mtcars)
mtcars2 <- mtcars[,1:length(mtcars)-2]
a <- data.frame(mtcars)
a
a[1:length(a)-1]
size(a[1:length(a)-1])
a[1:length(a)-1],)
a[,c(1:length(a)-1])
a[,c(1:length(a)-1)]
a <- data.frame(mtcars)
a
a[,c(1:length(a)-1)]
str(mtcars)
head(mtcars)
mtcars2 <- mtcars[,c(1:length(mtcars)-2)]
class(mtcars2)
class(mtcars)
mtcars2 <- mtcars[,c(1:length(mtcars)-2)]
head(mtcars2)
mtcars2 <- mtcars[,c(1:-2)]
a[c(1:length(a)-1)]
mtcars2 <- mtcars[1:-2]
mtcars2 <- mtcars[-c("gear","carb")]
mtcars2 <- mtcars[c("gear","carb")]
head(mtcars2)
str(mtcars)
vioplot(mpg~cyl, data=mtcars)
vioplot(mpg~cyl, data=mtcars,
col="gold", border="brown", colMed="magenta",
names = c("4 cyl", "6 cyl","8 cyl"),
xlab = "Number of Cylinders", ylab = "Miles per Gallon", main="Car Mileage by Cylinder")
#데이터가 각각 있는 경우 합쳐서 그래프 그리기
c4 <- mtcars$mpg[mtcars$cyl==4]
c6 <- mtcars$mpg[mtcars$cyl==6]
c8 <- mtcars$mpg[mtcars$cyl==8]
c4
vioplot(c4, c6, c8,
col="gold", border="brown", colMed="magenta",
names = c("4 cyl", "6 cyl","8 cyl"),
xlab = "Number of Cylinders", ylab = "Miles per Gallon", main="Car Mileage by Cylinder")
#산점도
#자동차 무게와 연비
x <- mtcars$wt
y <- mtcars$mpg
plot(x,y, pch=20, col="pink", ann=FALSE) #ann=FALSE 축제목 안나타나게게
max(x); max(y)
plot(x,y, pch=20, col="pink", ann=FALSE,
xlim=c(0,6), ylim=c(0,36))
vioplot(y, col="lightblue", rectCol = "gray", lty = 2, add = TRUE) #add = TRUE 기존 위에 추가가
vioplot(x, col="tomato", rectCol = "brown", lty = 1, add = TRUE, horizontal = TRUE) #horizontal = TRUE 수평으로
vioplot(x, col="tomato", rectCol = "brown", lty = 1, add = TRUE, horizontal = TRUE,#horizontal = TRUE 수평으로
wex=6) #wex=6크기 키우기. 기본은 1
vioplot(x, col="tomato", rectCol = "brown", lty = 1, add = TRUE, horizontal = TRUE,
wex=6, #wex=6크기 키우기. 기본은 1
at=4)#위치치
plot(x,y, pch=20, col="pink", ann=FALSE,
xlim=c(0,6), ylim=c(0,36))
vioplot(y, col="lightblue", rectCol = "gray", lty = 2, add = TRUE) #add = TRUE 기존 위에 추가
vioplot(x, col="tomato", rectCol = "brown", lty = 1, add = TRUE, horizontal = TRUE,
wex=6, #wex=6크기 키우기. 기본은 1
at=4)#위치치
title("Car Mieage vs. Car weight",
xlab="Weight(1,000lbs)", ylab="Miles per Gallon")
#점도표
str(mtcars)
head(mtcars)
dotchart(mtcars$mpg)
dotchart(mtcars$mpg, labels = row.names(mtcars))
dotchart(mtcars$mpg, labels = rownames(mtcars))
dotchart(mtcars$mpg, labels = row.names(mtcars), cex = 0.7,
xlab="Miles per Gallon", main="Mileage for Car Model")
cars <- mtcars[order(mtcars$mpg),]
cars
cars$cyl.f <- factor(cars$cyl, levels=c(4,6,8), labels = c("4cyl","6cyl","8cyl"))
cars
dotchart(mtcars$mpg, labels = row.names(mtcars), cex = 0.7,
xlab="Miles per Gallon", main="Mileage for Car Model",
groups = cars$cyl.f, gcolor = "red")#실린더를 범주로 추가
#색상지정
cars$colors[cars$cyl.f=="4cyl"] <- "maroon"
cars$colors[cars$cyl.f=="6cyl"] <- "deepskyblue"
cars$colors[cars$cyl.f=="8cyl"] <- "darkgreen"
head(cars)
dotchart(mtcars$mpg, labels = row.names(mtcars), cex = 0.7,
xlab="Miles per Gallon", main="Mileage for Car Model",
groups = cars$cyl.f, gcolor = "red",#실린더를 범주로 추가
color = cars$colors,pch=19
)
VADeaths #버지니아의 사망률률
dotchart(VADeaths)
dotchart(t(VADeaths), cex=0.8)
dotchart(VADeaths)
dotchart(t(VADeaths), cex=0.8)
#선도표
Orange
tree1 <- subset(Orange, Tree==1)
tree1
plot(tree1$age, tree1$circumference, xlab="Age(days)", ylab="Circumference(mm)",
main="Growth of Orange Tree 1")
plot(tree1$age, tree1$circumference, xlab="Age(days)", ylab="Circumference(mm)",
main="Growth of Orange Tree 1",
type="l")
plot(tree1$age, tree1$circumference, xlab="Age(days)", ylab="Circumference(mm)",
main="Growth of Orange Tree 1",
type="b")#선도표 + 점
plot(tree1$age, tree1$circumference, xlab="Age(days)", ylab="Circumference(mm)",
main="Growth of Orange Tree 1",
type="o")#선도표 + 점 겹치게게
xlim=range(Orange$age)
ylim=range(Orange$circumference)
plot(xlim=xlim, ylim=ylim, type="n",#그래프 틀만 그리기
xlab="Age(days)", ylab="Circumference(mm)", las=1, bty="l",#bty="l"그래프 틀 생성성
main="Growth of Orange Tree 1")
plot(xlim=xlim, ylim=ylim, type="n",#그래프 틀만 그리기
xlab="Age(days)", ylab="Circumference(mm)", las=1, bty="l",#bty="l"그래프 틀 생성성
main="Growth of Orange Tree 1")
plot(xlim=xlim, ylim=ylim, type="n",las=1, bty="l",#그래프 틀만 그리기 #bty="l"그래프 틀 생성
xlab="Age(days)", ylab="Circumference(mm)",
main="Growth of Orange Tree 1")
plot(xlim=xlim, ylim=ylim)
plot(xlim, ylim, type="n",las=1, bty="l",#그래프 틀만 그리기 #bty="l"그래프 틀 생성
xlab="Age(days)", ylab="Circumference(mm)",
main="Growth of Orange Tree 1")
ntree <- max(as.numeric(Orange$Tree))
ntree
colors <- c(1:ntree)+1
colors
linetype <- c(1:ntree)
linetype
plotchart <- c(1:ntree)+18
plotchart
lines(tree$age, tree$circumference,
type="b",lwd=2,
lty=linetype[i], col=colors[i], pch=plotchart[i])
for (i in 1:ntree){
tree <- subset(Orange, Tree==i)
lines(tree$age, tree$circumference,
type="b",lwd=2,
lty=linetype[i], col=colors[i], pch=plotchart[i])
}
legend(xlim[1], ylim[2], 1:ntree,
col = colors, pch=plotchart, lty = linetype,
title = "Trees")
plot(xlim, ylim, type="n",las=1, bty="l",#그래프 틀만 그리기 #bty="l"그래프 틀 생성
xlab="Age(days)", ylab="Circumference(mm)",
main="Growth of Orange Tree")
for (i in 1:ntree){
tree <- subset(Orange, Tree==i)
lines(tree$age, tree$circumference,
type="b",lwd=2,
lty=linetype[i], col=colors[i], pch=plotchart[i])
}
legend(xlim[1], ylim[2], 1:ntree,
col = colors, pch=plotchart, lty = linetype,
title = "Trees")
#산점도
str(iris)
plot(iris$Petal.Length, iris$Petal.Width)
with(iris, plot(Petal.Length, Petal.Width))
plot(Petal.Width ~ Petal.Length, iris)
as.integer(Species)
as.integer(iris$Species)
with(iris, plot(Petal.Length, Petal.Width,
pch=as.integer(Species)+18
))
legend(x=1.2, y=2.4, legend = c("Setosa","Versicolor","Virginica")) #x,y,좌표로 위치 지정
legend(x=1.2, y=2.4, legend = c("Setosa","Versicolor","Virginica"), #x,y,좌표로 위치 지정
pch=as.integer(Species)+18)
legend(x=1.2, y=2.4, legend = c("Setosa","Versicolor","Virginica"), #x,y,좌표로 위치 지정
pch=as.integer(iris$Species)+18)
legend(x=1.2, y=2.4, legend = c("Setosa","Versicolor","Virginica"), #x,y,좌표로 위치 지정
pch=c(1:3)+18)
with(iris, plot(Petal.Length, Petal.Width,
pch=as.integer(Species)+18
))
legend(x=1.2, y=2.4, legend = as.character(iris$Species), #x,y,좌표로 위치 지정
pch=1:length(levels(iris$Species))+18)
legend(x=1.2, y=2.4, legend = as.character(iris$Species), #x,y,좌표로 위치 지정
pch=c(1:length(levels(iris$Species)))+18)
with(iris, plot(Petal.Length, Petal.Width,
pch=as.integer(Species)+18
))
legend(x=1.2, y=2.4, legend = as.character(levels(iris$Species)), #x,y,좌표로 위치 지정
pch=c(1:length(levels(iris$Species)))+18)
legend(locator(1), legend = as.character(levels(iris$Species)), #x,y,좌표로 위치 지정
pch=c(1:length(levels(iris$Species)))+18)
#locator 옵션 사용
with(iris, plot(Petal.Length, Petal.Width,
pch=as.integer(Species)+18
))
legend(locator(1), legend = as.character(levels(iris$Species)), #x,y,좌표로 위치 지정
pch=c(1:length(levels(iris$Species)))+18)
palette()
#색깔
with(iris, plot(Petal.Length, Petal.Width,
pch=as.integer(Species),
col=as.integer(Species)))
legend(locator(1), legend = as.character(levels(iris$Species)), #locator 함수 호출하면 마우스로 x,y,좌표로 위치 지정가믕
pch=1:length(levels(iris$Species)),
col = 1:length(levels(iris$Species)))
legend(x=1.2, y=2.4, legend = as.character(levels(iris$Species)),
fill = c(1:length(levels(iris$Species)))+1)
with(iris, plot(Petal.Length, Petal.Width,
pch=19,
col=as.integer(Species))+1)
legend(x=1.2, y=2.4, legend = as.character(levels(iris$Species)),
fill = c(1:length(levels(iris$Species)))+1)
with(iris, plot(Petal.Length, Petal.Width,
pch=19,
col=as.integer(Species))+1)
col=(as.integer(Species))+1)
with(iris, plot(Petal.Length, Petal.Width,
(as.integer(Species))+1
(as.integer(Species))+1
with(iris, plot(Petal.Length, Petal.Width,
pch=19,
col=(as.integer(Species))+1))
with(iris, plot(Petal.Length, Petal.Width,
pch=19,
col=(as.integer(Species))+1))
legend(x=1.2, y=2.4, legend = as.character(levels(iris$Species)),
fill = c(1:length(levels(iris$Species)))+1)
library(car)
install.packages("car")
library(car)
scatterplot(mpg~wt | cyl , data=mtcars, boxplots="xy", lwd=2, pch=c(15,16,17),
col=c("red","green","blue"))
#산점도 행렬
str(iris)
plot(iris[1:2])
plot(iris[1:4])
plot(iris)
plot(iris[1:4])
pairs(iris[1:4])
pairs(~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width, data=iris)
pairs(~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width, data=iris, upper.panel=NULL)
install.packages("psych")
library(psych)
pairs.panels(iris[1:4])
points?
pairs.panels(iris[1:4], pch=21, )
?points
pairs.panels(iris[1:4], pch=21, bg=c("red","green","blue")[iris$Species],
lm=TRUE) #회귀선 그림림
pairs.panels(iris[1:4], pch=as.numeric(levels(iris$Species))+20, bg=c("red","green","blue")[iris$Species],
lm=TRUE) #회귀선 그림
as.numeric(levels(iris$Species))+20
pairs.panels(iris[1:4], pch=as.numeric(iris$Species)+20, bg=c("red","green","blue")[iris$Species],
lm=TRUE) #회귀선 그림
pairs.panels(iris[1:4], pch=as.numeric(iris$Species)+20, bg=c("red","green","blue")[iris$Species],
lm=TRUE,
hist.col = "gold") #회귀선 그림
#상관계수의 통계적 유의성 확인을 위해
install.packages("PerformanceAnalytics")
library(PerformanceAnalytics)
chart.Correlation(iris[1:4], pch=21,
bg=c("red","green","blue")[iris$Species],lm=TRUE)
>>>>>>> dfd9e4129c832753f1bef3ebb8adeecd6e88a3b5
