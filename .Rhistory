#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
#list
lst <- list(odd=c(1,3,5), even=c(2,4,6))
unlist(lst)
#matrix 만들기
matrix(unlist(lst),3,2,dimnames=list(NULL, names(lst)))
matrix(lst)
as.matrix(lst)
as.data.frame(lst)
as.data.frame(lst2)
str(as.data.frame(lst2))
#data frame
dfm <- data.frame(odd=c(1,3,5), even=c(2,4,6))
dfm
dfm[,1]
dfm[[1]]
str(dfm[,1])
str(dfm[[1]])
dfm[1,]
str(dfm[1,])
as.matrix(dfm)
as.vector(as.matrix(dfm))
dfm2 <- data.frame(odd=c(1,3,5), even=c(2,4,6), count=c("one", "two", "three"))
dfm2
as.vector(as.matrix(dfm2))
#dataframe->list
as.list(dfm2)
as.matrix(dfm2)
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
install.packages(quantmod)
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
install.packages("quantmod")
#결합 - 데이터셋 결합 | 열 결합 | 행 결합 | 공통 열에 의한 결합
#yahoo의 주가 데이터 다운로드 하여 주가 데이터 옆에 환율 데이터 까지 넣는 법
#install.packages("quantmod")
library(quantmod)
sec <- getSymbols(Symbols = "005930.ks",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
sec <- as.data.frame(sec)
str(sec)
head(sec)
head(sec[c("005930.KS.Close", "005930.KS.Volume")])
sec <- cbind(date=rownames(sec),
symbol="005930.KS",
sec[c("005930.KS.Close", "005930.KS.Volume")])
rownames(sec) <- NULL #행이름 지지우기
colnames(sec)[c(3,4)] <- c("close", "volume")
head(sec)
#현대자동차 주가정보 다운로드
hmc <- getSymbols(Symbols = "005387.ks",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
hmc <- as.data.frame(hmc)
head(hmc)
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
sec[c("005387.KS.Close", "005930.KS.Volume")])
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
sec[c("005387.KS.Close", "005387.KS.Volume")])
#현대자동차 주가정보 다운로드
hmc <- getSymbols(Symbols = "005387.KS",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
hmc <- as.data.frame(hmc)
head(hmc)
hmc <- cbind(date=rownames(hmc),
symbol="005387.KS",
hmc[c("005387.KS.Close", "005387.KS.Volume")])
head(hmc)
rownames(hmc) <- NULL
head(hmc)
colnames(hmc)[c(3,4)] <- c("close", "volume")
head(hmc)
#행의 방향으로 결함
stock <- rbind(sec, hmc)
head(stock)
stock
#merge로 환율 데이터 옆에 붙이기
#finance.yahoo.com
fx <- getSymbols(Symbols = "KRW=X",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
fx
#데이터프레임 형태로 변환
fx <- as.data.frame(fx)
str(fx)
head(fx["KRW=X.Close"])
fx <- cbind(date=rownames(fx),
fx[c("KRW=X.Close")])
head(fx)
rownames(fx) <- NULL
head(fx)
colnames(fx) <- "close"
head(fx)
#merge로 환율 데이터 옆에 붙이기
#finance.yahoo.com
fx <- getSymbols(Symbols = "KRW=X",
from="2021-10-01",
to="2021-12-31",
auto.assign = FALSE)
#데이터프레임 형태로 변환
fx <- as.data.frame(fx)
str(fx)
head(fx["KRW=X.Close"])
fx <- cbind(date=rownames(fx),
fx[c("KRW=X.Close")])
head(fx)
rownames(fx) <- NULL
colnames(fx)[c(2)] <- "close"
head(fx)
#공통된 날짜 기준으로 merge
instersect(names(sec), names(fx))
#공통된 날짜 기준으로 merge
intersect(names(sec), names(fx))
report <- merge(sec, fx, by="date")
report
v <- c(10,9,8,7,5,4,3,2,1)
match(7,v)
match(c(11,5,3,1,0), v)
v <- c(10,9,8,7,6,5,4,3,2,1)
match(7,v)
match(c(11,5,3,1,0), v)
head(mtcars)
car <- mtcars
car["name"] <- rownames(car)
rownames(car) <- NULL
head(car)
highhp.car <- car[car$hp>145,]
highhp.car
lightwt.car <- car[car$wt>3.2,]
lightwt.car
lightwt.car <- car[car$wt<3.2,]
lightwt.car
#힘이 좋으면서 가벼운 차 위의 2dataframe 합치기
index <- match(highhp.car$name, lightwt.car$name)
index
lightwt.car[na.omit(index),]
v <- c(10,9,8,7,6,5,4,3,2,1)
7 %in% v
c(1,2,3) %in% v
c(11,5,0) %in% v
index2 <- highhp.car$name %in% lightwt.car$name
index2
highhp.car[index2,]
#subset | 인덱싱 | $ [[ ]] [ ] | 무작위 표본(random sample) 추출 | 결측값 | 구간별 범주화
str(mtcars)
mtcars$mpg
mtcars[[mpg]]
mtcars[["mpg"]]
mtcars[[1]]
mtcars["mpg"]
mtcars[c(1,4)]
mtcars[c("mpg","hp")]
mtcars[-c(2,3,4)]
mtcars[-1]
mtcars[1] <- NULL
mtcars
mtcars[c(-1, 2)]
str(iris)
iris[1:5]
iris[1:5,]
iris[1:5]
iris[1:2]
iris[,c(1,4)]
iris[,1]
iris[,1, drop=FALSE]
#원래 형태로 하고 싶으면 행렬인덱싱보다 리스트 인덱싱을 쓰는 것이 안전하다
iris[1]
iris[1:5,c(1,4)]
#조건에 따라서 만드는 경우
iris[iris$Sepal.Length>7,]
iris[iris$Sepal.Length>7,c(1,2)]
iris[iris$Sepal.Length>7,c(1,2,5)]
subset(iris, subset=(Sepal.Length>7),
select =c(1,2,5))
#랜덤 샘플링 할 때
sample(x1:10, size=5)
#랜덤 샘플링 할 때
sample(x=1:10, size=5)
sample(x=10, size=5)
#복원추출
sample(x=10, size = 5, replace = TRUE)
sample(10)
#sample이 일정하게 나오면 좋겠다. seed 지정
set.seed(1)
sample(x=10, size = 5, replace=TRUE)
sample(x=10, size = 5, replace=TRUE)
set.seed(1)
sample(x=10, size = 5, replace=TRUE)
sample(iris,3)
set.seed(1)
index <- sample(nrow(iris),3)
index
iris[index]
iris[index,]
#데이터셋에 중복된 값 제거하고 subset 생성하기
duplicated(c(1,2,3,1,1,3,4))
#결측값이 있는 경우 결측값이 뭔지 지정해줘야 함
openFileInOS("product_missing.csv")
#install.packages("tidyverse")
library(readr)
read_csv(file = "product.csv") #첫 행에 열이름이 있는 경우
id <- c("A001","A002","A003")
name <- c("Mouse","Keyboard","USB")
price <- c(30000,90000,50000)
product <- data.frame(id=id, name=name, price=price)
product
product <- rbind(product, c("A001","Mouse",30000))
product
duplicated(product)
product[duplicated(product), ]
product[-duplicated(product), ]
product[!duplicated(product), ]
which(duplicated(product))
product[-index,]
index <- which(duplicated(product))
product[-index,]
#방법4
unique(product)
#방법5
str(airquality)
complete.cases(airquality)
airquality.nona <- airquality[complete.cases(airquality),]
str(airquality)
str(airquality.nona)
#방법6
airquality.nona2 <- na.omit(airquality)
str(airquality.nona2)
#범주화 하기
cut(x=iris$Sepal.Width, breaks=c(0,1,2,3,4,5))
cut(x=iris$Sepal.Width, breaks=5)#임의로 5개의 구간을 나눔눔
#빈도 계산을 위해서는 table 사용
iris.cut <- cut(x=iris$Sepal.Width, breaks=c(0,1,2,3,4,5))
table(iris.cut)
summary(iris.cut)
iris.cut <- cut(x=iris$Sepal.Width,
breaks = c(0,1,2,3,4,5),
labels = c("smaller","small","medium","big","biger"))
table(iris.cut)
#week11-1
#sort
x <- c(3,7,5,1,2,5)
sort(x)
sort(x, decreasing = TRUE)
#NA가 포함되어 있는 경우
length(x) <- 7
x
sort(x)
sort(x, na.last = TRUE)
sort(x, na.last = FALSE)
y <- c(33,11,55,22,44)
order(y)
y[order(y)]
sort(y)
z <- c("Superman","Batman","Ironman","Antman","Spiderman")
df <- data.frame(y,z)
df
#y열 기준
order(df$y)
df[order(df$y),]
df[order(df$y,decreasing=TRUE),]
df[order(-df$y),]
y <- c(33,11,55,22,44)
z <- c("Superman","Batman","Ironman","Antman","Spiderman")
w <- c("can fly", "can not fly","can fly","cannot fly")
df <- data.frame(y,z,w)
w <- c("can fly", "can not fly","can fly","cannot fly","can fly")
df <- data.frame(y,z,w)
df
df[order(df$w, df$y),]
install.packages("dplyr")
#install.packages("dplyr")
library(dplyr)
df[order(desc(df$w),y),]
arrange(df, w, y)
arrange(df, desc(w), y)
head(mtcars)
#am 변수를 가지고 집단으로 만들어봄
mtcars <- within(mtcars,
am <- factor(am,
levels = c(0,1),
labels = c("Automatic","Manual")))
head(mtcars)
g <- split(mtcars$mpg, f=mtcars$am)
g
g[[1]]
mean(g[[1]])
mean(g[["Manual"]])
sapply(g,mean)
unstack(data.frame(mtcars$mpg, mtcars$am))
head(iris)
unstack(data.frame(iris$Sepal.Length, iris$Species))
gg<- unstack(data.frame(iris$Sepal.Length, iris$Species))
head(gg)
str(gg)
summary(gg)
tapply(X=iris$Sepal.Length, INDEX = iris$Species, FUN=mean)
tapply(X=iris$Sepal.Length, INDEX = iris$Species, FUN=length)
with(tapply(mtcars$mpg, list(cyl,am), mean))
str(mtcars)
with(tapply(mtcars$mpg, list(cyl ,am), mean))
with(tapply(mpg, list(cyl ,am), mean))
with(mtcars,tapply(mpg, list(cyl ,am), mean))
with(mtcars,tapply(mpg, list(Cylincer=cyl ,Transmission=am), mean))
FUN=mean)
with(mtcars,
aggregate(x=mpg, by=list(Cylincer=cyl ,Transmission=am),
FUN=mean))
aggregate(mtcars[1:6], list(Group.cyl=cyl ,Group.am=am),
FUN=mean))
aggregate(mtcars[1:6], list(Group.cyl=cyl ,Group.am=am),
FUN=mean)
aggregate(mtcars[1:6], list(Group.cyl=mtcars$cyl ,Group.am=mtcars$am),
FUN=mean)
aggregate(iris[1:4], list(Species=iris$Species), mean)
by(data=iris, INDICES = iris$Species, FUN=summary)
by(data=iris, INDICES = iris$Species, FUN=summary)
by(iris, iris$Species, function(x) mean(x$Sepal.Length))
#범주형 변수가 주어지면 변수가 몇개인가 알려줌
table(mtcars$gear)
table(mtcars$am)
table(mtcars$am, mtcars$gear)
table(mtcars$am, mtcars$gear)
cut(mtcars$mpg, breaks = 5)
#균일한 구간으로 나눔
mpg.cut <- cut(mtcars$mpg, breaks = 5)
table(mpg.cut)
head(airquality)
install.packages("dplyr")
#install.packages("dplyr")
library(dplyr)
filter(airquality, Month==6)
air <- filter(airquality, Month==6)
head(air)
airquality[airquality$Month==6,]
subset(airquality, subset = (Month==6))
air <- filter(airquality, Month==6, Temp>90)
head(air)
air <- filter(airquality, Month==6 & Temp>90)
head(air)
air <- filter(airquality, Ozone>80 | Temp>90)
head(air)
#원하는 행 추출
slice(airquality, 6:10)
#n():dataframe의 행번호
slice(airquality, (n()-4):n())
#여러 열을 지정가능 순서대로 arrange됨
arrange(airquality, Temp, Month, Day)
arrange(airquality, desc(Temp), Month, Day)
#원하는 열을 선택
air <- select(airquality, Month, Day, Temp)
head(air)
air <- select(airquality, Temp:Day)
head(air)
#원하지 않는 열 빼기
air <- select(airquality, -(Temp:Day))
head(air)
#선택하면서 열이름 바꿀수도 있음
air <- select(airquality, Solar=Solar.R)
head(air)
#이름만 변경하려면 rename()을 써서 특정 열의 이름 변경
air <- rename(airquality, Solar=Solar.R)
head(air)
#중복되지 않는 값 출력
distinct(select(airquality, Month))
#새로운 열을 추가할 때 사용
air <- mutate(airquality,
Temp.c=(Temp-32)/1.8,
Diff=Temp.c-mean(Temp.c))
head(air)
#base package 포함된 transform()
transform(airquality,
Temp.c=(Temp-32)/1.8,
Diff=Temp.c-mean(Temp.c))
transform(airquality,
Temp.c=(Temp-32)/1.8)
head(air)
#요약통계
summarise(airquality,
mean(Temp))
#요약통계
summarise(airquality,
mean(Temp, na.rm = TRUE),
median(Temp, na.rm = TRUE),
sd(Temp, na.rm = TRUE),#표준편차
max(Temp, na.rm = TRUE),
min(Temp, na.rm = TRUE))
#요약통계
summarise(airquality,
Mean=mean(Temp, na.rm = TRUE),
Median=median(Temp, na.rm = TRUE),
SD=sd(Temp, na.rm = TRUE),#표준편차
Max=max(Temp, na.rm = TRUE),
Min=min(Temp, na.rm = TRUE))
#요약통계
summarise(airquality,
Mean=mean(Temp, na.rm = TRUE),
Median=median(Temp, na.rm = TRUE),
SD=sd(Temp, na.rm = TRUE),#표준편차
Max=max(Temp, na.rm = TRUE),
Min=min(Temp, na.rm = TRUE),
N=n(),#열의 개수
Distinct.Month=n_distinct(Month)#고유한 값의 개수
Distinct.First=first(Month)#첫번째 값
Distinct.Last=last(Month)
)
#요약통계
summarise(airquality,
Mean=mean(Temp, na.rm = TRUE),
Median=median(Temp, na.rm = TRUE),
SD=sd(Temp, na.rm = TRUE),#표준편차
Max=max(Temp, na.rm = TRUE),
Min=min(Temp, na.rm = TRUE),
N=n(),#열의 개수
Distinct.Month=n_distinct(Month),#고유한 값의 개수
Distinct.First=first(Month),#첫번째 값
Distinct.Last=last(Month)
)
#무작위 추출, 지정된 개수, 지정된 비율로
sample_n(airquality, 5)
#무작위 추출, 지정된 개수, 지정된 비율로
sample_n(airquality, 5, seed=1)
#무작위 추출, 지정된 개수, 지정된 비율로
sample_n(airquality, 5, seed=1)
#
air.group <- group_by(airquality, Month)
class(air.group)
air.group
summarise(air.group,
Mean.Temp=mean(Temp, na.rm=TRUE))
summarise(air.group,
Mean.Temp=mean(Temp, na.rm=TRUE),
sd.Temp=sd(Temp, na.rm = TRUE),
Days=n())
#pipe operator %>%
#결과를 다음에 첫 인자로 전달 가능
iris %>% head
head(iris)
1:10 %>% mean
mean(1:10)
a1 <- select(airquality, Ozon, Temp, Month)
head(a1)
a1 <- select(airquality, Ozon, Temp, Month)
a1 <- select(airquality, Ozone, Temp, Month)
head(a1)
a2 <- group_by(a1, Month)
head(a2)
a2
a3 <- summarise(a2,
Mean.ozone=mean(Ozone,na.rm=TRUE),
Mean.Temp=mean(Temp, na.rm=TRUE))
a3
a4 <- filter(a3, Mean.ozone>40 | Mean.Temp>80)
a4
#pipe operator 사용해서 똑같이 해보기
air <- airquality %>%
select( Ozone, Temp, Month) %>%
group_by(Month) %>%
summarise(Mean.ozone=mean(Ozone,na.rm=TRUE),
Mean.Temp=mean(Temp, na.rm=TRUE)) %>%
filter(Mean.ozone>40 | Mean.Temp>80)
air
#조인
df1 <- data.frame(x=1:6, y=month.name[1:6])
df2 <- data.frame(x=7:12, y=month.name[7:12])
df1
df2
df3 <- bind_rows(df1, df2)
df3
df4 <- data.frame(z=month.abb)
df4
#열의 방향으로 결합
bind_cols(df3, df4)
#열의 방향으로 결합
df5 <- bind_cols(df3, df4)
df5
cbind(df3,df4)
band_members
band_instruments
inner_join(band_members, band_instruments)
#by 인수를 지정
inner_join(band_members, band_instruments, by="name")
#outer join 한쪽 데이터셋에만 있어도 포함 합집합
left_join(band_members, band_instruments, by="name")#왼쪽 데이터셋 기준
right_join(band_members, band_instruments, by="name")#오른쪽 데이터셋 기준
full_join(band_members, band_instruments, by="name")#왼쪽,오른쪽 둘 모두 데이터셋 기준
band_instruments2
#행이름 다른경우 지정
full_join(band_members, band_instruments2, by=c("name"="airtist"))
#행이름 다른경우 지정
full_join(band_members, band_instruments2, by=c("name"="artist "))
#행이름 다른경우 지정
full_join(band_members, band_instruments2, by=c("name"="artist"))
#행이름 유지하려면
full_join(band_members, band_instruments2, by=c("name"="artist"),keep=TRUE)
#공통열이 일치하는 경우 추출
semi_join(band_members, band_instruments, by="name")
#공통열이 일치하지 않는 경우 추출
anti_join(band_members, band_instruments, by="name")
